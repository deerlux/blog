title: 理解Docker 
date: 2014-10-31 22:16:39
tags: 虚拟化
---

原文出自https://docs.docker.com/introduction/understanding-docker/， 本文由<deerlux@163.com>翻译。

什么是Docker？
=============

Docker是一个用于开发、装载和运行程度的开放平台，可使你的程序迁移更加便捷。在Docker中可以将你的应用程序和基础设施层隔离，并且还可以将你的基础设施当作程序一样进行管理。Docker可以帮助你更加快速地打包你代码、更加快速地测试、更加快速地部署，并且可以减少写代码到部署运行代码的周期。

Docker通过将一个轻量级的容器虚拟化平台和一组标准工作流程、工具进行集成，来帮助你方便地管理和部署应用。

核心的是，Docker提供了一种在一个安全隔离的环境中运行几乎所有程序方式，这种隔离性和安全性允许你在同一主机上同时运行多个容器，而容器的这种轻量级特性，意味着你可以节省更多的硬件资源，因为你不必消耗运行hypervisor所需要的额外负载的。

围绕容器虚拟化Docker提供了一些工具和一个平台，可为你提供以下帮助：

* 将应用程序（包括支撑的组件）放入docker容器中；
* 将这些容器打包并分发给你的团队，以便于后续的开发和测试；
* 将这些容器部署到生产环境中，即可以是本地的数据中心也可以在云端。

我可以用Docker做些什么？
======================

快速分发你的应用
----------------

Docker是开发过程中较为理想的助手，它允许你在包含了你的应用和服务的本地容器中进行开发，然后帮你完成集成和部署。

例如，你的开发人员可以在本地写代码然后通过Docker与其他同事共享，当他们完成了各自的开发任务后，可以将他们的代码推送到一个测试的环境中进行测试，完成测试后便可以将相应的Docker镜像部署到生产环境中。

更方便地进行部署和调整规模
----------------------

Docker这种基于容器的平台具有高度的便携性，它可以无缝地运行于开发者的本地主机、数据中心其他的物理机或虚拟机、或者云端。

Docker的便携性和其天然的轻量特性易于实现动态地负载管理，你可以利用Docker快速地增减应用和服务的部署规模，Docker的速度保证了这种规模的调整近乎实时。

更高密度的部署应用和运行更多的应用
----------------------------------

由于Docker轻量并且快速，因此相对于基于Hypervisor的虚拟机的部署方式，Docker提供了一种更可行和划算的替代方案，这对于高密度部署环境尤其有用，例如在构建私有云或平台即服务环境时，当然，当你想在有限的资源里部署更多的应用时，Docker对于小中型的部署也非常有用。

Docker主要包括哪些组件？
======================

Docker主要包括两个组件：

* Docker: 开源的容器虚拟化平台；
* [Docker Hub](https://hub.docker.com/) ：用于分享和管理Docker容器的软件即服务平台。

**注**: Docker在Apache 2.0开源协议下进行授权。

Docker的架构？
==============

Docker是一种Client/Server的架构，Docker客户端与Docker daemon进行交互，daemon负责构建、运行和发布Docker容器。客户端即可以和服务端运行在同一个系统中，也可以连接远程的daemon。Docker的客户端的daemon通过RESTful API进行sockets 通信。

![docker-architecture.svg](https://docs.docker.com/article-img/architecture.svg)

Docker守护进程
--------------

就像上图所示，Docker守护进程(daemon)在主机上运行，用户不能直接和守护进程打交道，但是可以通过docker客户端与其进行交互。

Docker客户端
------------

Docker客户端——`docker`二进制文件的功能之一——是Docker的初始用户界面，它接收用户的命令并反馈，并且与Docker的守护进行交互。

Docker内部机制
--------------

理解Docker的内部机制，你需要明白如下三个组件：

* Docker镜像
* Docker注册中心
* Docker容器

### Docker镜像


Docker镜像是一个只读的模块。例如，一个镜像可以包含一个安装了apache WEB服务应用的Ubuntu操作系统。镜像用来创建Docker容器。Docker提供了构建新镜像或升级原有镜像的较为便利的方式，或者你也可以下载别人已经创建好的镜像。Docker镜像是Docker的**构建**组件。

### Docker注册中心

Docker注册中心用于上传和下载镜像，有公共注册中心和私有注册中心两种。公共注册中心为[Docker Hub](https://hub.docker.com/)，它提供了大量的现成镜像，你可以构建自己的镜像上传到上面，也可以在上面下载别人构建的镜像。Docker注册中心是Docker的**发布**组件。

### Docker容器

Docker容器与一个目录很类似，它包含了一个应用程序运行所需要的一切内容。每个容器都是基于一个Docker镜像制作的。Docker容器可被运行、开始、停止、迁移或者是删除。每个容器均是一个隔离的、安全的应用平台。Docker容器是Docker的**运行**组件。

Docker怎样工作的
-----------------

至此，我们已经知道了：

1. 你可以构建用于存储你的应用程序的镜像；
1. 你可以从Docker镜像中创建容器用来运行你的应用；
1. 你可以通过[Docker Hub](https://hub.docker.com/)或者你自己的注册中心来共享Docker镜像


那我们看看Docker是怎么将这些元素组合在一起工作的。

### Docker镜像是如何工作的

我们已经知道Docker镜像实质上是一些用于加载Docker容器的只读模板，每个镜像包括很多层。Docker利用[union file systems](http://en.wikipedia.org/wiki/UnionFS)将这些层组合为一个镜像。Union file systems允许相互隔离的文件或目录透明的叠加在一起，而呈现为一个统一的文件系统。

Docker如此轻量化的原因也是由于这些层的存在。当你对一个Docker镜像进行修改时——例如将一个应用升级为一个新的版本——会构建一个新的层，因此，与虚拟机的替换整个镜像或完全构建的方式不同，Docker仅对相关的层进行添加或升级。所以你仅需要发布镜像的更新部分而不必发布整个镜像，这种方式使得镜像的发布更加快速和简单。

每个镜像始于一个基础镜像，例如：`ubuntu`便是一个基础的Ubuntu镜像，`fedora`是一个基础的Fedora镜像。你也可以将你自己制作的镜像作为基础镜像，例如你可以将一个Apache镜像作为一个Web应用的基础镜像。

> 注意：Docker一般从[Docker Hub](https://hub.docker.com/)上获取基础镜像。

Docker镜像从这些基础镜像中按照一系列的步骤进行制作，我们称这些步骤为**指令**，每个指令在你的镜像中创建一个新的层，指令包括以下行为：

* 运行一条命令；
* 添加一个文件或目录；
* 创建一个环境变量；
* 从此镜像中加载一个容器时需要运行的进程。

这些指令存储在`Dockerfile`中，Docker在构建镜像过程中读取这个`Dockerfile`，运行里面的指令并返回最终的镜像。

### Docker注册中心如何工作的

Docker注册中心是Docker镜像的存储中心，当你构建完一个镜像后便可以将其推送到[Docker Hub](https://hub.docker.com)或你自己的注册中心。

利用Docker客户端，你可以搜索已经发布的镜像，然后将其拉取到你的Docker主机上，以便于从这些镜像中构建容器。

[Docker Hub](https://hub.docker.com)为镜像提供了公共的和私有的存储空间。公共的存储空间任何人均可以在上面搜索和下载，私有存储空间仅对你本人或你的团队开放搜索以及拉取下载，你可以通过[这里](https://hub.docker.com/plans)注册一个私有的存储空间。

### 容器是如何工作的

一个容器包括操作系统、用户添加的文件以及相关的元数据。我们知道，每个容器都是从镜像中构建出来的，这个镜像告诉Docker容器用到什么资源、当容器加载时启动哪个进程以及容器启动时的其他配置。Docker镜像是只读的，当Docker从一个镜像运行一个容器时，它会在镜像的上层添加一个用于运行应用的可读写的层（利用的就是上文提到的union file system）。

### 运行一个容器时到底发生了什么

Docker客户端通过直接运行`docker`或者通过API调用的方式，可以通知Docker的守护进程运行一个容器。

``` shell
$ sudo docker run -i -t ubuntu /bin/bash
```

我们来看一下这个命令，Docker客户端利用`docker`命令跟一个`run`的选项启动一个容器，一个最小配置的Docker客户端运行一个容器需要告诉Docker守护进程以下事项：

* 此容器基于什么镜像来构建，此处是`ubuntu`——一个基础的Ubuntu镜像；
* 需要在容器中运行的命令，此处是`/bin/bash`——在容器中启动一个Bash Shell。

那么我们看看运行上述命令时到底发生了什么？

按照顺序，Docker依次干了如下事情：

* **拉取`ubuntu`镜像** : Docker首先检查一下`ubuntu`镜像在本地服务器上存不存在，如果不存在，则自动从[Docker Hub](https://hub.docker.com/)中下载，如果已经存在则直接利用这个镜像来启动一个新的容器。
* **创建一个新的容器**: 如果Docker本地服务器中存在这个镜像，那么就据此来启动一个容器。
* **分配一个文件每户并且将其挂载到一个可读写的层**: 容器在此文件系统中被创建，并且将其作为一个可读写的层添加到镜像中。
* **分配一个网络或桥接的接口**: 创建一个网络的接口以便于Docker容器能够访问本机。
* **设置一个IP地址**: 为此容器从地址池中找到并绑定一个IP地址。
* **执行指定的进程**: 运行你的应用程序，然后；
* **获取并提供应用程序的输出**: 连接标准输入、标准输出和标准错误接口，这样你便可以观察到程序运行的一切。

现在你已经运行了一个容器，这样你便可以管理你的容器、与应用程序进行交互，当运行结束是停止或者删除你的容器。

## 底层技术问题

Docker是用Go语言实现的，用到了一些Linux内核的特性实现上述功能。

### 命名空间（namespaces）

Docker在为容器提供一个隔离的工作空间时，用到了`命名空间`的技术，当你运行一个容器时，Docker会为此容器创建一组命名空间。

这样便可以提供一个隔离的层：每个容器运行在自己的命名空间中，而外部不能访问这个层。

Docker用到的一些命名空间有：

* **`pid`命名空间**: 用于隔离进程（PID：Process ID）；
* **`net`命名空间**: 用于管理网络；
* **`ipc`命名空间**: 用于访问IPC资源（IPC：InterProcess Communication）；
* **`mnt`命名空间**: 用于管理挂载点（MNT：Mount）；
* **`uts`命名空间**: 用于隔离内核和版本标识（UTS：Unix Timesharing System）。

### 控制组（Control Groups）

Docker还用到了另外一项技术叫`cgroups`或者叫控制组（control groups）。实现程序运行环境的隔离的关键在于使这些程序只用到他们需要的资源，这就能够保证这些容器是主机服务环境小社会中的好市民。控制组允许Docker在不同的容器之间共享硬件资源，需要时添加一些限制和约束，例如限制一个容器最大访问内存量。

### 统一文件系统（Union file systems）

统一文件系统或者说是UnionFS，是创建层的时候用到的文件系统，使文件系统非常轻量和快速。Docker使用统一文件系统为容器构建blocks，Docker可以使用几种不同的文件系统：AUFS、btrfs、vfs以及DeviceMapper。

### 容器格式

Docker容器将这些组件合并在一起，我们称之为容器格式，容器的缺省格式称为`libcontainer`。Docker还支持利用[LXC](https://linuxcontainers.org/)技术的传统Linux容器格式，未来还将会支持其他的容器格式，例如：与BSD Jails或者Solaris Zones实现整合。

# 下一步

安装Docker，请参照[installation section](https://docs.docker.com/installation/#installation)

Docker用户指南，请参照[深入学习Docker](https://docs.docker.com/userguide/)








