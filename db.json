{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1}],"Cache":[{"_id":"source/_posts/alembic.md","shasum":"3c27cb5086d4006a41a949baa8b8dd0beb43cc33","modified":1449142733656},{"_id":"source/_posts/alembic.md~","shasum":"dfbd0563067eb0f15cffe1681b0665a1cd4258ae","modified":1449142472073},{"_id":"source/_posts/anacron.md","shasum":"883e2be83426a73dd1e4de91de2b387d550c15e4","modified":1460042793139},{"_id":"source/_posts/anacron.md~","shasum":"3d68819454a826278cf3aec316f5225595a36eb3","modified":1460040017980},{"_id":"source/_posts/archlinux-nginx-fastcgi.md","shasum":"ccce10f679d2c04852d79384536a3e7ba77c4cec","modified":1449141957493},{"_id":"source/_posts/docker-systemd-socket-activation.md","shasum":"fa02c9fcbf0713736ec9bfc3b1575c3a32b8589a","modified":1449141957493},{"_id":"source/_posts/gitolite.md","shasum":"47c87a24c04d390a85462df8ea6b176cf89206c0","modified":1449141957493},{"_id":"source/_posts/guochan-os.md","shasum":"61427085de47242d894ffe9e16ff0d5fc0aa7ca0","modified":1449141957494},{"_id":"source/_posts/haomama.md","shasum":"26942d37db6c264d20dfded944c2c9c155dd701d","modified":1449141957495},{"_id":"source/_posts/hello-world.md","shasum":"774b507901d9b17991ace2a70263b6dd6d11999a","modified":1450870466916},{"_id":"source/_posts/hexo-blog.md","shasum":"0c5da688bce10ad7afa1dde98ea9576b9bfff2c5","modified":1449141957495},{"_id":"source/_posts/k8sarch.png","shasum":"58b8543770c8c6f37f24ee3ceaa042531a34b2d8","modified":1459330602303},{"_id":"source/_posts/k8sstart.md","shasum":"b6f16edfa72e2fca931ae0ebf51376a1c7946de4","modified":1459331310849},{"_id":"source/_posts/k8sstart.md~","shasum":"0330bbb1f9345b212e86180f8b69021f8cb741e3","modified":1459331047755},{"_id":"source/_posts/openshift.md","shasum":"1c04da6d11e65a8a349205e8e6f15c6d44d23537","modified":1459551988269},{"_id":"source/_posts/openshift.md~","shasum":"59083c1083d38195187ddd7a36e73e474d20b5a9","modified":1459551653869},{"_id":"source/_posts/sqlalchemy.md","shasum":"c74e6386f7ee1cfe8821e20c50e3fd93be1b1fbc","modified":1449141957495},{"_id":"source/_posts/understanding-docker.md","shasum":"9db4daaa6ac1438f4b3e57e9a35eda46231c5e89","modified":1449141957495},{"_id":"source/_posts/whatisk8s.md","shasum":"8bd703aecf250d401dab0c631d5f78cd8a51f0be","modified":1458224572941},{"_id":"source/_posts/whatisk8s.md~","shasum":"30197b43612ec5d3c3fa82fdaaaaa54885609b9f","modified":1458224312105},{"_id":"source/_posts/三体.md","shasum":"f61471f97f2db797a0cacda4add7fd792b99e740","modified":1449141957495},{"_id":"source/_posts/反欺骗的艺术.md","shasum":"45a9731e192ed0116bd2f0c34be44e6f16e98240","modified":1449141957495},{"_id":"source/_posts/数据之巅.md","shasum":"1f766c709654d4c010dab33630dacc0874eb6500","modified":1449141957496},{"_id":"source/_posts/openshift_add.png","shasum":"bc7ca946ff780e5ff45b379c4c465acc9a772e10","modified":1459498563058},{"_id":"source/_posts/openshift_appname.png","shasum":"e48aa3eaab3b93f61e6cfeaf9ad708a2c1237d3a","modified":1459498989474},{"_id":"source/_posts/openshift_db.png","shasum":"c8bcd4e678eab298282059558275f0e2d26aa58e","modified":1459500687335},{"_id":"source/_posts/openshift_django.png","shasum":"2df2b95193b4bd11b6e303b626c52e2fc28c1b33","modified":1459498936294},{"_id":"source/_posts/openshift_appnext.png","shasum":"3c27e9ea52559776e37ddcf5a9d5c2255721dda3","modified":1459500491402},{"_id":"source/_posts/openshift_signin.png","shasum":"e820ace7e22025a3ad6cd2fb166d346dd598ed43","modified":1459470590263},{"_id":"themes/landscape/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1450870466916},{"_id":"themes/landscape/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1450870466916},{"_id":"themes/landscape/_config.yml","shasum":"e1fa116f99b8ab7c23ab75b59932a1a5b9aeb1e3","modified":1450870466916},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","shasum":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1450870466916},{"_id":"themes/landscape/README.md","shasum":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1450870466916},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/archive.ejs","shasum":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/article.ejs","shasum":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/footer.ejs","shasum":"4b19c1080c9e6c2acd922a88ed29d183a3b5bc09","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/head.ejs","shasum":"da9a4ab32efc44c098f317fe64e2335989929b0e","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1450870466919},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1450870466919},{"_id":"themes/landscape/layout/_widget/archive.ejs","shasum":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1450870466919},{"_id":"themes/landscape/layout/_widget/category.ejs","shasum":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1450870466919},{"_id":"themes/landscape/layout/_widget/tag.ejs","shasum":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1450870466919},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","shasum":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1450870466919},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","shasum":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1450870466919},{"_id":"themes/landscape/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1450870466919},{"_id":"themes/landscape/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1450870466919},{"_id":"themes/landscape/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1450870466919},{"_id":"themes/landscape/layout/layout.ejs","shasum":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1450870466919},{"_id":"themes/landscape/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1450870466919},{"_id":"themes/landscape/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1450870466919},{"_id":"themes/landscape/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1450870466919},{"_id":"themes/landscape/package.json","shasum":"85358dc34311c6662e841584e206a4679183943f","modified":1450870466919},{"_id":"themes/landscape/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450870466919},{"_id":"themes/landscape/source/css/_extend.styl","shasum":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/archive.styl","shasum":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/footer.styl","shasum":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/header.styl","shasum":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","shasum":"890349df5145abf46ce7712010c89237900b3713","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","shasum":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","shasum":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1450870466919},{"_id":"themes/landscape/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1450870466919},{"_id":"themes/landscape/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1450870466919},{"_id":"themes/landscape/source/css/_variables.styl","shasum":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1450870466919},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450870466919},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450870466919},{"_id":"themes/landscape/source/css/_partial/article.styl","shasum":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1450870466919},{"_id":"themes/landscape/source/css/style.styl","shasum":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450870466922},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450870466922},{"_id":"themes/landscape/source/js/script.js","shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1450870466922},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450870466922},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450870466929},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450870466932},{"_id":"themes/landscape/source/css/images/banner.jpg","shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1450870466932},{"_id":"public/js/script.js","modified":1511521053625,"shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1511521053628,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1511521053630,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1511521053632,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1511521053633,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1511521053635,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1511521053636,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1511521053637,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1511521053639,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1511521053643,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1511521053645,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1511521053647,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1511521053648,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1511521053649,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1511521053651,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1511521053654,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1511521054035,"shasum":"e9ae89d3eaf09b4fb3b48f3da5e58e74ea5875b0"},{"_id":"public/css/images/banner.jpg","modified":1511521054185,"shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1511521054187,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1511521054189,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1511521054192,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1511521054193,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1511521054195,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/2016/04/07/anacron/index.html","modified":1511521054225,"shasum":"717686dc530eca091ab08d2df957a03664f87799"},{"_id":"public/2016/04/01/openshift/index.html","modified":1511521054236,"shasum":"e458b20680f6a0cfe8619b01deb73c932d157b43"},{"_id":"public/2016/03/30/k8sstart/index.html","modified":1511521054241,"shasum":"bea286ad13df8c7cd63d893eb867e0f0a72feeb4"},{"_id":"public/2016/03/17/whatisk8s/index.html","modified":1511521054254,"shasum":"04322df4c57c7d44a305bfc961e55d12c4ff723e"},{"_id":"public/2015/12/23/hello-world/index.html","modified":1511521054260,"shasum":"c69289ce5a8e2e3b040ab5a7dbfb6406dfd1bcb5"},{"_id":"public/2015/12/03/alembic/index.html","modified":1511521054265,"shasum":"70ab31559fb525498180eea9bf858c707d5e9d7f"},{"_id":"public/2015/04/21/gitolite/index.html","modified":1511521054269,"shasum":"d59baba4231d93283e03f4afb159ae224f70d3f6"},{"_id":"public/2015/03/17/archlinux-nginx-fastcgi/index.html","modified":1511521054273,"shasum":"cd5bde905512bf34e79c7bdd7d0da2c8e386e11e"},{"_id":"public/2015/03/08/docker-systemd-socket-activation/index.html","modified":1511521054282,"shasum":"fcaa075c88b91f751e2c48965c282f8ab6f72b8c"},{"_id":"public/2014/11/15/haomama/index.html","modified":1511521054287,"shasum":"f031837c0e79268ddc1a0a72327caf83f14bf81c"},{"_id":"public/2014/10/31/understanding-docker/index.html","modified":1511521054300,"shasum":"5d2b13d8268a2972afbde3557a54b1891ba6a262"},{"_id":"public/2014/10/24/guochan-os/index.html","modified":1511521054310,"shasum":"1a1c23f2ed02e17dcd2dd206b8df570099e3cce4"},{"_id":"public/2014/10/23/sqlalchemy/index.html","modified":1511521054321,"shasum":"2d95437b313a8c7837138c039e7a3b7bfc618f6b"},{"_id":"public/2014/10/14/数据之巅/index.html","modified":1511521054325,"shasum":"22fbc93de841a89a955c620a07be7090920133e1"},{"_id":"public/2014/10/11/hexo-blog/index.html","modified":1511521054331,"shasum":"9f084ea3ff8f58255886b026e515b6316c111dd7"},{"_id":"public/2014/10/11/三体/index.html","modified":1511521054342,"shasum":"5041b9a92fe18fe6c4d4a6f62cae0bd7997d7137"},{"_id":"public/2014/10/11/反欺骗的艺术/index.html","modified":1511521054346,"shasum":"f0396b1bfaa55e01d26ef01a6b07086db6d5ab8e"},{"_id":"public/archives/index.html","modified":1511521054355,"shasum":"ae58b5b4ca545e180f15509c59e696fcfb83b80e"},{"_id":"public/archives/page/2/index.html","modified":1511521054360,"shasum":"338b8ace5dfebf7908fa3439282c45c2c8546166"},{"_id":"public/archives/2014/index.html","modified":1511521054366,"shasum":"59b272937f17aa4e5af9f3c3ab410ba8530dbe38"},{"_id":"public/archives/2014/10/index.html","modified":1511521054371,"shasum":"ad8812560e2e28c6dfc4dd2b950cd25b1c53742e"},{"_id":"public/archives/2014/11/index.html","modified":1511521054374,"shasum":"2bd6bf4273631ce582532d16f80765268cbf0e18"},{"_id":"public/archives/2015/index.html","modified":1511521054378,"shasum":"45eafcab4d00b4360b70b0379f90ed5b095c4ed3"},{"_id":"public/archives/2015/03/index.html","modified":1511521054381,"shasum":"d8c1fb7859fb900a05e3a8fa30423c439ead5390"},{"_id":"public/archives/2015/04/index.html","modified":1511521054385,"shasum":"b00582c009307ab551d38080659626a9058c880c"},{"_id":"public/archives/2015/12/index.html","modified":1511521054389,"shasum":"9f8db8e3282b303de6ad7a5f98252a7ba9a0d222"},{"_id":"public/archives/2016/index.html","modified":1511521054392,"shasum":"c1a5d6f74b269c18ad76a8a193a702ea5023fc74"},{"_id":"public/archives/2016/03/index.html","modified":1511521054395,"shasum":"ec2f55e02d860daab47a4228e471a076d712dac5"},{"_id":"public/archives/2016/04/index.html","modified":1511521054398,"shasum":"1ad7cb8b11eab202359497e4fa9b46b0b43c964b"},{"_id":"public/index.html","modified":1511521054407,"shasum":"1e97ab9636192da3b093cd69756305ad40ce3f0f"},{"_id":"public/page/2/index.html","modified":1511521054416,"shasum":"137267274e635f57cf27c26fa635c149b1c4f4e9"},{"_id":"public/tags/python-linux/index.html","modified":1511521054421,"shasum":"6e14d6280af93698cd3579de2c1fb848c84a6372"},{"_id":"public/tags/读书笔记/index.html","modified":1511521054426,"shasum":"6b5daee92e5c3492690baa814686072ad4291f2b"},{"_id":"public/tags/Linux-云计算/index.html","modified":1511521054429,"shasum":"dc39cc8cd2eebd5f7736fcf1f7abb4f6ca7403d5"},{"_id":"public/tags/虚拟化/index.html","modified":1511521054435,"shasum":"1c2ec97d432c8c0ed11b1406168b5d6afa2cb030"},{"_id":"public/tags/Python/index.html","modified":1511521054438,"shasum":"f306371d73def23fc7969e165377e973250fd64a"},{"_id":"public/tags/Linux/index.html","modified":1511521054441,"shasum":"40ece75cba43d0063b16dd5d9377ff47543114d7"},{"_id":"public/tags/Misc/index.html","modified":1511521054443,"shasum":"f5de2c371dc86bd36b67140be02e7061e18d4952"},{"_id":"public/tags/git-部署/index.html","modified":1511521054445,"shasum":"d8dea7aab41cb483b49005514ad7bf6d7f9dc54b"},{"_id":"public/tags/系统运维/index.html","modified":1511521054448,"shasum":"e856790415bcef430bcf557df0e3036d44883bc4"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"利用alembic实现sqlalchemy与数据库映射的版本管理","date":"2015-12-03T11:34:32.000Z","_content":"\n说实在的真不知道该怎么起这篇文章的标题。需求是这样的，数据库的设计与定义采用sqlalchemy ORM的方式进行定义，那么如果对需要对数据库结构进行修改呢，谁家的数据库设计也不会保证一步到位啊，这种模式下是不是我要先修改ORM定义，再用一个SQL修改数据库结构，因为当我的数据库已经在运行之后，总不能再Base.metadata.create_all()了吧。alembic就是为了解决这种问题而存在的。\n\n# 安装\n\n安装十分简单：`pip install alembic\n","source":"_posts/alembic.md","raw":"title: 利用alembic实现sqlalchemy与数据库映射的版本管理\ndate: 2015-12-03 19:34:32\ntags: python linux\n---\n\n说实在的真不知道该怎么起这篇文章的标题。需求是这样的，数据库的设计与定义采用sqlalchemy ORM的方式进行定义，那么如果对需要对数据库结构进行修改呢，谁家的数据库设计也不会保证一步到位啊，这种模式下是不是我要先修改ORM定义，再用一个SQL修改数据库结构，因为当我的数据库已经在运行之后，总不能再Base.metadata.create_all()了吧。alembic就是为了解决这种问题而存在的。\n\n# 安装\n\n安装十分简单：`pip install alembic\n","slug":"alembic","published":1,"updated":"2015-12-03T11:38:53.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwr00000aziyaz2sqky2"},{"title":"数据之巅——从美国人历史上如何重视数据讲起大数据的前生今世","date":"2014-10-14T13:52:56.000Z","_content":"\n作者的文笔非常好，从美国建国时讲起，讲这个年轻的国家如何从一开始就重视数据的应\n用的。古时候，美国的开国元勋们为了更公平地分配各州在议会中的席位，一直以各州的\n人口基数为基础，而如果人口更多则这个州也将会承担更多的对于联邦政府的责任，所以\n没有哪个州会对这种数据人为造假，因为有一种制衡机制。也正是因为如此，人口的多少\n与这个州的权利和义务干系重大，因此在美国形成了以重视人口普查数据为起点的重视一\n切数据的观念。每一项决策要想在议会通过，都需要有大量的数据进行支撑权衡投入和产\n出，以至于不得不对人的生命进行定价，而且有一套较为说服力的定价算法。数据基础建\n设以及数据共享应用是大数据时代的基础中的基础，美国人很明白这个道理。\n\n因此，大数据的概念和技术应用最先兴起在美国也就不足为怪了。而反观我国，目前大数\n据的概念被炒的有点过热了，而且很多人都在跟风炒概念，特别是政府决策层。个人觉得\n我国离大数据时代还有一定的距离，而且必将在大数据时代落后于美国，因为我们国家的\n决策机制并非是数据驱动，而是领导意愿驱动的。一个决策的科学与否与领导人的个人能\n力、战略眼光有强的关联性，这种情况下形不成一种重视数据的风气，因此也就不会出现\n大数据时代共享共用数据的环境。里面讲的神州数码的一位专家说，我们的差距主要是在\n**观念和文化** ，我深表认同。\n\n\n","source":"_posts/数据之巅.md","raw":"title: 数据之巅——从美国人历史上如何重视数据讲起大数据的前生今世\ndate: 2014-10-14 21:52:56\ntags:\n---\n\n作者的文笔非常好，从美国建国时讲起，讲这个年轻的国家如何从一开始就重视数据的应\n用的。古时候，美国的开国元勋们为了更公平地分配各州在议会中的席位，一直以各州的\n人口基数为基础，而如果人口更多则这个州也将会承担更多的对于联邦政府的责任，所以\n没有哪个州会对这种数据人为造假，因为有一种制衡机制。也正是因为如此，人口的多少\n与这个州的权利和义务干系重大，因此在美国形成了以重视人口普查数据为起点的重视一\n切数据的观念。每一项决策要想在议会通过，都需要有大量的数据进行支撑权衡投入和产\n出，以至于不得不对人的生命进行定价，而且有一套较为说服力的定价算法。数据基础建\n设以及数据共享应用是大数据时代的基础中的基础，美国人很明白这个道理。\n\n因此，大数据的概念和技术应用最先兴起在美国也就不足为怪了。而反观我国，目前大数\n据的概念被炒的有点过热了，而且很多人都在跟风炒概念，特别是政府决策层。个人觉得\n我国离大数据时代还有一定的距离，而且必将在大数据时代落后于美国，因为我们国家的\n决策机制并非是数据驱动，而是领导意愿驱动的。一个决策的科学与否与领导人的个人能\n力、战略眼光有强的关联性，这种情况下形不成一种重视数据的风气，因此也就不会出现\n大数据时代共享共用数据的环境。里面讲的神州数码的一位专家说，我们的差距主要是在\n**观念和文化** ，我深表认同。\n\n\n","slug":"数据之巅","published":1,"updated":"2015-12-03T11:25:57.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslws60003aziypvlvpats"},{"title":"反欺骗的艺术——一本权威全面的骗子和反骗子指南","date":"2014-10-11T13:38:19.000Z","_content":"\n**反欺骗的艺术**\n\nKevin d. Mitnick, William L. Simon 著，潘爱民 译\n清华大学出版社，2014年9月第1版。\n\n读后感\n------\n\n忘记从什么地方看到了这本书的推荐了，米特尼克——社会工程学的始祖，写了一本欺骗的\n艺术，于是上网找看有没有中译本，结果找到了一本反欺骗的艺术，还以为此大牛又写了\n本，仔细一看这本书的英文封面才明白，The art of Deception，就是我要找的这本书，\n而且中译本刚刚出版。对我国出版业（或是出版监管部门）我说什么呢，明明叫欺骗的艺\n术，为什么不忠实原著呢，可是看完这本书后还真有些理解这些人的良苦。\n\n这是一本讲信息安全的书，看似是一本技术性较强的书，但其实和技术其实没多大关系，\n书中举了大量的社交工程师利用简单的或复杂的社交技能，从而使技术严密的安全系统形\n同虚设，以达到从企业获取敏感信息的目的。这些例子中，攻击者要常常冒充其他部门的\n新手、行政助理、合作伙伴、机房管理员、信息技术服务商等角色，受害者从保安、助理\n、接线员到核心岗位人员均有，运用一定的社交技巧再辅以部分技术手段，使一些经验丰\n富的社交工程师几乎无往不利。但所有这些例子几乎都有个共同点，即受害者均以为行骗\n者是他们声称的那个人。书中最后也给出了人们为什么会犯这样的错误，实际上是骗子们\n利用了一些人类的天性，人们倾向于相信几类人：权威、讨人喜欢的人、帮助的施予者、\n和其他值得信任的人行为一致的人、满足自己贪欲的人等等。所有这些东西实际上都在说\n明在信息安全领域，人是最关键也是很脆弱的一个环节，如果人这个环节出了问题，再多\n的技术防范措施都是徒劳。很多企业在构建安全体系时并没有把人的因素给予充分的重视\n，从而使这些社交工程师们总能够得逞。\n\n杂感1\n-----\n\n读这本书的过程中看到作者举的那些例子我还在想，他那些例子中的受害者如果是在中国\n的话可能未必那么容易受骗，我国是个骗子横行的国度，很多人都已经具备了一定的防骗\n常识了，一些社交工程师的骗术在讲究诚信的美国能够成功在中国倒也未必成功。想到这\n一点，自己心里的滋味都不知是庆幸还是难堪了。\n\n我现实生活中遇到的两起行骗事件\n-------------------------------\n\n我实际遇到过两起行骗的案件，第一次有人声称我买的车有优惠退税，让我提供一个卡号\n，我留了个心眼，留了个错的卡号，果不其然，对方还要我的密码，钱的转入是不需要密\n码的，这个常识我还是懂得的，况且此人声称是北京税务部门的人却操一口南方口音，打\n死我也不相信北京的税务局会有人这么重的南方口音。第二次，我在药房网买药的记录被\n盗，攻击者号称是药房网的客服，说有一笔交易本来我已经付款了，但是系统出问题误将\n这次交易设置成了分期付款，要帮我取消。这个骗子还注册了一个和药房网的客服电话十\n分像的电话，药房网的电话是 ``4006509988`` ，这个骗子来电的号码显示是\n``+4006509988`` ，我差点就相信了。后来打电话到药房网再次确认，官方客服说这是一\n起行骗，而且已经接到了其他用户的投诉了。再后来那人再打电话给我，被我骂了一通。\n我在挫败这起行骗时实际上用到了书中所提到的一条重要的防骗经验，回电确认对方是他\n声称的那个人。\n\n杂感2\n------\n\n这本书不能落入骗子之手。\n\n\n","source":"_posts/反欺骗的艺术.md","raw":"title: 反欺骗的艺术——一本权威全面的骗子和反骗子指南\ndate: 2014-10-11 21:38:19\ntags: 读书笔记\n---\n\n**反欺骗的艺术**\n\nKevin d. Mitnick, William L. Simon 著，潘爱民 译\n清华大学出版社，2014年9月第1版。\n\n读后感\n------\n\n忘记从什么地方看到了这本书的推荐了，米特尼克——社会工程学的始祖，写了一本欺骗的\n艺术，于是上网找看有没有中译本，结果找到了一本反欺骗的艺术，还以为此大牛又写了\n本，仔细一看这本书的英文封面才明白，The art of Deception，就是我要找的这本书，\n而且中译本刚刚出版。对我国出版业（或是出版监管部门）我说什么呢，明明叫欺骗的艺\n术，为什么不忠实原著呢，可是看完这本书后还真有些理解这些人的良苦。\n\n这是一本讲信息安全的书，看似是一本技术性较强的书，但其实和技术其实没多大关系，\n书中举了大量的社交工程师利用简单的或复杂的社交技能，从而使技术严密的安全系统形\n同虚设，以达到从企业获取敏感信息的目的。这些例子中，攻击者要常常冒充其他部门的\n新手、行政助理、合作伙伴、机房管理员、信息技术服务商等角色，受害者从保安、助理\n、接线员到核心岗位人员均有，运用一定的社交技巧再辅以部分技术手段，使一些经验丰\n富的社交工程师几乎无往不利。但所有这些例子几乎都有个共同点，即受害者均以为行骗\n者是他们声称的那个人。书中最后也给出了人们为什么会犯这样的错误，实际上是骗子们\n利用了一些人类的天性，人们倾向于相信几类人：权威、讨人喜欢的人、帮助的施予者、\n和其他值得信任的人行为一致的人、满足自己贪欲的人等等。所有这些东西实际上都在说\n明在信息安全领域，人是最关键也是很脆弱的一个环节，如果人这个环节出了问题，再多\n的技术防范措施都是徒劳。很多企业在构建安全体系时并没有把人的因素给予充分的重视\n，从而使这些社交工程师们总能够得逞。\n\n杂感1\n-----\n\n读这本书的过程中看到作者举的那些例子我还在想，他那些例子中的受害者如果是在中国\n的话可能未必那么容易受骗，我国是个骗子横行的国度，很多人都已经具备了一定的防骗\n常识了，一些社交工程师的骗术在讲究诚信的美国能够成功在中国倒也未必成功。想到这\n一点，自己心里的滋味都不知是庆幸还是难堪了。\n\n我现实生活中遇到的两起行骗事件\n-------------------------------\n\n我实际遇到过两起行骗的案件，第一次有人声称我买的车有优惠退税，让我提供一个卡号\n，我留了个心眼，留了个错的卡号，果不其然，对方还要我的密码，钱的转入是不需要密\n码的，这个常识我还是懂得的，况且此人声称是北京税务部门的人却操一口南方口音，打\n死我也不相信北京的税务局会有人这么重的南方口音。第二次，我在药房网买药的记录被\n盗，攻击者号称是药房网的客服，说有一笔交易本来我已经付款了，但是系统出问题误将\n这次交易设置成了分期付款，要帮我取消。这个骗子还注册了一个和药房网的客服电话十\n分像的电话，药房网的电话是 ``4006509988`` ，这个骗子来电的号码显示是\n``+4006509988`` ，我差点就相信了。后来打电话到药房网再次确认，官方客服说这是一\n起行骗，而且已经接到了其他用户的投诉了。再后来那人再打电话给我，被我骂了一通。\n我在挫败这起行骗时实际上用到了书中所提到的一条重要的防骗经验，回电确认对方是他\n声称的那个人。\n\n杂感2\n------\n\n这本书不能落入骗子之手。\n\n\n","slug":"反欺骗的艺术","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslws90004aziye68fc19a"},{"title":"三体——中国作家写的具有世界级水准的科幻小说","date":"2014-10-11T14:19:34.000Z","_content":"\ndeerlux@163.com 2014年 09月 30日\n\n宇宙中到底有没有其他生命体或文明？\n\n如果有的话，对地球来说到底意味着什么？\n人类五千年的文明发展史如果拿到宇宙以亿年为单位的深化过程中应该如何看待？\n\n如果地球的末日来临人类社会将呈现一种什么样的状态？\n\n人类要为自己的无知傲慢和自私付出什么样的代价？是人类才有的特性吗？\n\n作者铺开了一幅宏大的宇宙、太阳系的发展脉络画面，凭自己深厚的物理学识和哲学思考\n向我们展示了几个世纪的地球文明发展与存亡。以下内容涉及剧透，不喜勿喷。\n\n第一部讲的是受文革深度迫害的而对人类丑恶深恶痛绝的苦情女最终变成愤世女，发现了\n太阳可以放大地球上发出的电磁波，从而使人类向外星系发出召唤的功率达到恒星的级别\n，这个信号当然被外星文明收到了，而且是因受三体无规律运行而苦苦挣扎寻求一块更适\n合生存地的文明。于是他们在同样对人类丑恶感到失望的愤世男及其三体组织的帮助下，\n用两个光速运行的智子锁死了地球的基础研究，方法很简单，以光速干扰你所有的粒子对\n撞机，并且将地球上所有的信息实时传送给了三体。战争还没有开始，地球对三体世界已\n经是战场透明了，三体派出了一支舰队，四个世纪便可以到达地球。\n\n第二部。三体文明思维透明，不会撒谎，而人类撒谎的本领估计放在宇宙的角度也可以名\n列前矛，不利用这个优势简直是浪费，但人类除了思想外的一切对于三体世界已经透明了\n，所以人类想用自己撒谎的本领启动了面壁计划掩饰自己真正的战略意图。四位面壁者被\n赋予了很大的权利运用地球上的一切资源，两个都失败了，被地球上三体支持者们直接识\n破。人类对于战胜三体看来基本无望了，那又何必担心四个世纪之后的末日呢，安心享受\n现在吧，\"给岁月以文明，而不是给文明以岁月\"，于是人类的觉悟反而迎来了新的繁荣，\n科技的发展榨取了基础理论积累的最后一点价值，使人类的舰队比三体舰队速度还要快，\n人类完全有理由相信战胜三体指日可待，然而真正在末日之战来临时人类的傲慢以及与外\n星文明的差距彻底毁灭了人类生存的希望，三千支恒星级战舰组成的傲慢的舰队瞬间被毁\n，人类还有没有生存的希望？宇宙文明有两个公理，由这两个公理可以推导出宇宙社会学\n，而宇宙社会学中最重要的黑暗森林法则是三体世界的命门，这个命门最终被面壁者发现\n。并且已经试验证实，一颗恒星受光粒打击被灭，宇宙中存在无数的文明，如果你暴露了\n自己，高级文明如何知道你是善意还是恶意，但为了生存还是先把你灭了吧，连三体也对\n这种其他文明的打击很是惧怕，人类掌握了这个命门后以与三体同归于尽胁迫三体世界，\n从而造成一种基于威慑的战略平衡，人类得以延续。\n\n第三部的画面最为宏大。屌丝男临死得到一笔钱，他用这钱向联合国买了颗不起眼的星星\n送给了自己暗恋的白富美，白富美参与了一项将一颗人类大脑送到三体航队云的计划，于\n是屌丝男的大脑被很悲催的送走了。由于威慑的存在，人类与三体相安多年，使人类几乎\n都忘记了三体的攻击性，所以将威慑的决策权给了一个充满爱的白富美。三体人早就判断\n出这个充满爱的白富美不会启动同归于尽的威慑，于是迅速做出行动，毁灭你与你何干。\n人类被三体人赶到了澳大利亚，人类在这块仅留在大陆上可以互相为粮食，直到数目减少\n到这块大陆适合生存的地步。好在逃逸在外太空的一艘战舰上还有一群没那么有爱的人类\n，向宇宙广播了三体的坐标，三体世界被灭，太阳系被灭只是时间问题，剩下的三体人也\n没有精力和地球人耗下去了。人类自以为是的启动了掩体计划，以为在太阳系受到打击时\n自己能够通过躲在远日行星的背面免于一死，孰不知如此简单的道理对于能够灭绝一个恒\n星系的文明来讲能不明白吗。 屌丝男的大脑最终是被三体舰队捕获了，并且获得了新生，\n逃走的这批三体人允许他给白富美一次对话，屌丝男通过三个童话故事告诉人类如何生存\n下去，但人类却没有最终理解这三个童话故事的内涵，恒星级的灭绝就来临了。这次更狠\n，将整个太阳系直接降维到一个二维平面，这是神一级的同归于尽的灭绝方式。白富美最\n终靠空间曲率驱动的光速飞船逃了出去，也最终悟出了屌丝男三个童话的全部内涵，空间\n曲率驱动的光速飞船一方面可以逃逸另一方面可以造成一片慢雾，以了降低光速的代价将\n太阳系被神级文明看作是安全的。但一切为时已晚，以光速飞行的飞船大幅度穿越时空，\n到达了屌丝男送她的星星的行星上，幸运的是这颗星星物理条件适合人居住，不幸的是人\n文环境不适合，这是其他文明星际战争的路线。神级文明可以改变宇宙规律，可以再造宇\n宙，当全宇宙降维，在这里仅有的人类何去何从。\n","source":"_posts/三体.md","raw":"title: 三体——中国作家写的具有世界级水准的科幻小说\ndate: 2014-10-11 22:19:34\ntags: 读书笔记\n---\n\ndeerlux@163.com 2014年 09月 30日\n\n宇宙中到底有没有其他生命体或文明？\n\n如果有的话，对地球来说到底意味着什么？\n人类五千年的文明发展史如果拿到宇宙以亿年为单位的深化过程中应该如何看待？\n\n如果地球的末日来临人类社会将呈现一种什么样的状态？\n\n人类要为自己的无知傲慢和自私付出什么样的代价？是人类才有的特性吗？\n\n作者铺开了一幅宏大的宇宙、太阳系的发展脉络画面，凭自己深厚的物理学识和哲学思考\n向我们展示了几个世纪的地球文明发展与存亡。以下内容涉及剧透，不喜勿喷。\n\n第一部讲的是受文革深度迫害的而对人类丑恶深恶痛绝的苦情女最终变成愤世女，发现了\n太阳可以放大地球上发出的电磁波，从而使人类向外星系发出召唤的功率达到恒星的级别\n，这个信号当然被外星文明收到了，而且是因受三体无规律运行而苦苦挣扎寻求一块更适\n合生存地的文明。于是他们在同样对人类丑恶感到失望的愤世男及其三体组织的帮助下，\n用两个光速运行的智子锁死了地球的基础研究，方法很简单，以光速干扰你所有的粒子对\n撞机，并且将地球上所有的信息实时传送给了三体。战争还没有开始，地球对三体世界已\n经是战场透明了，三体派出了一支舰队，四个世纪便可以到达地球。\n\n第二部。三体文明思维透明，不会撒谎，而人类撒谎的本领估计放在宇宙的角度也可以名\n列前矛，不利用这个优势简直是浪费，但人类除了思想外的一切对于三体世界已经透明了\n，所以人类想用自己撒谎的本领启动了面壁计划掩饰自己真正的战略意图。四位面壁者被\n赋予了很大的权利运用地球上的一切资源，两个都失败了，被地球上三体支持者们直接识\n破。人类对于战胜三体看来基本无望了，那又何必担心四个世纪之后的末日呢，安心享受\n现在吧，\"给岁月以文明，而不是给文明以岁月\"，于是人类的觉悟反而迎来了新的繁荣，\n科技的发展榨取了基础理论积累的最后一点价值，使人类的舰队比三体舰队速度还要快，\n人类完全有理由相信战胜三体指日可待，然而真正在末日之战来临时人类的傲慢以及与外\n星文明的差距彻底毁灭了人类生存的希望，三千支恒星级战舰组成的傲慢的舰队瞬间被毁\n，人类还有没有生存的希望？宇宙文明有两个公理，由这两个公理可以推导出宇宙社会学\n，而宇宙社会学中最重要的黑暗森林法则是三体世界的命门，这个命门最终被面壁者发现\n。并且已经试验证实，一颗恒星受光粒打击被灭，宇宙中存在无数的文明，如果你暴露了\n自己，高级文明如何知道你是善意还是恶意，但为了生存还是先把你灭了吧，连三体也对\n这种其他文明的打击很是惧怕，人类掌握了这个命门后以与三体同归于尽胁迫三体世界，\n从而造成一种基于威慑的战略平衡，人类得以延续。\n\n第三部的画面最为宏大。屌丝男临死得到一笔钱，他用这钱向联合国买了颗不起眼的星星\n送给了自己暗恋的白富美，白富美参与了一项将一颗人类大脑送到三体航队云的计划，于\n是屌丝男的大脑被很悲催的送走了。由于威慑的存在，人类与三体相安多年，使人类几乎\n都忘记了三体的攻击性，所以将威慑的决策权给了一个充满爱的白富美。三体人早就判断\n出这个充满爱的白富美不会启动同归于尽的威慑，于是迅速做出行动，毁灭你与你何干。\n人类被三体人赶到了澳大利亚，人类在这块仅留在大陆上可以互相为粮食，直到数目减少\n到这块大陆适合生存的地步。好在逃逸在外太空的一艘战舰上还有一群没那么有爱的人类\n，向宇宙广播了三体的坐标，三体世界被灭，太阳系被灭只是时间问题，剩下的三体人也\n没有精力和地球人耗下去了。人类自以为是的启动了掩体计划，以为在太阳系受到打击时\n自己能够通过躲在远日行星的背面免于一死，孰不知如此简单的道理对于能够灭绝一个恒\n星系的文明来讲能不明白吗。 屌丝男的大脑最终是被三体舰队捕获了，并且获得了新生，\n逃走的这批三体人允许他给白富美一次对话，屌丝男通过三个童话故事告诉人类如何生存\n下去，但人类却没有最终理解这三个童话故事的内涵，恒星级的灭绝就来临了。这次更狠\n，将整个太阳系直接降维到一个二维平面，这是神一级的同归于尽的灭绝方式。白富美最\n终靠空间曲率驱动的光速飞船逃了出去，也最终悟出了屌丝男三个童话的全部内涵，空间\n曲率驱动的光速飞船一方面可以逃逸另一方面可以造成一片慢雾，以了降低光速的代价将\n太阳系被神级文明看作是安全的。但一切为时已晚，以光速飞行的飞船大幅度穿越时空，\n到达了屌丝男送她的星星的行星上，幸运的是这颗星星物理条件适合人居住，不幸的是人\n文环境不适合，这是其他文明星际战争的路线。神级文明可以改变宇宙规律，可以再造宇\n宙，当全宇宙降维，在这里仅有的人类何去何从。\n","slug":"三体","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsb0007aziytu921oil"},{"title":"什么是kubernetes","date":"2016-03-17T04:58:01.000Z","_content":"\n【译者按】译自[kubernetes官网文档](http://kubernetes.io/docs/whatisk8s/)，主要介绍kubernetes的基本概念以及应用场景，K8s的设计理念，以及K8s能干什么不能干什么。\n\n# 什么是kubernetes?\nKubernetes是一款应用于集群的，[容器自动部署、扩展和管理的开源平台](http://www.slideshare.net/BrianGrant11/wso2con-us-2015-kubernetes-a-platform-for-automating-deployment-scaling-and-operations)，提供了一种以容器为中心的基础架构。\n\n利用kubernetes，你可以快速高效地响应客户如下请求：\n* 应用程序的动态、精准部署\n* 应用程序的动态扩展\n* 无缝推出新功能\n* 按需优化使用硬件资源\n\n我们的目标是提供一套减轻应用程序在公用云或私有云上运行负担的，生态环境的组件和工具。\n\n## kubernetes是：\n\n* 便携的：公有云、私有云、混合云、多云\n* 可扩展的：模块化、即插即用、钩子化、组合化\n* 自动修复的：自动布局、自动重启、自动副本、自动伸缩\n\nKubernetes项目是2014年由Google公司启动的，Kubernetes在[Google公司15年生产环境经验基础上](https://research.google.com/pubs/pub43438.html)，结合了社区的一些优秀点子和实践而构建的。\n\n准备好[开始了](http://kubernetes.io/docs/getting-started-guides/)吗？\n\n# 为什么要用容器\n\n寻找一下你用[容器](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)理由？\n\n*传统方法*部署应用程序是利用操作系统的包管理器向主机上安装应用，这种方法的一个弊端是应用程序、配置、支撑库以及生命周期等经常与主机操作系统纠缠在一起，当然你也可以构建虚拟机镜像来实现可控的发布，但是虚拟机比较重量化并且其可移植性也不好。\n\n*新方法*部署容器则是基于操作系统级别的虚拟化而不是硬件层面的虚拟化实现的，这些容器相互之间以及容器与主机之间是隔离的：它们拥有自己的文件系统，共享运算资源，但它们彼此看不到对方。容器的构建也比虚拟机的构建要容易，由于它们不依赖于运行平台和文件系统，因此可以跨越云和操作系统发行版实现可移植性。\n\n因为容器小而快速，一个应用程序可以打包成容器镜像，这种应用与镜像的一一对应关系，彻底发挥了容器的好处。\n\n1. 永久的容器镜像可以在应用的开发阶段进行构建，而不是留在部署阶段，因为每个应用并不需要在其生命周期的其他阶段或是在正式交付生产环境时进行修改，这使得开发环境和生产环境高度一致。\n1. 容器相对于虚拟机更透明，便于监控和管理，特别是当容器的进程周期是由管理平台进行管理而不是由隐藏在容器中的超级进程进行管理时。\n1. 一个应用一个容器，对容器的管理相当于对应用的管理。\n\n容器的优点可以归结为:\n\n* **敏捷地进行应用构建和部署**: 相比于虚拟机的管理，容器的管理更为容易和高效。\n* **可连续进行开发、集成和部署**：采用快速回滚的方式，使其具备可靠和频繁的容器镜像构建和部署的能力（基于镜像的永久性）。\n* **开发和运维可分开考虑**：创建应用程序的容器镜像是在构建/发布阶段而不是在部署阶段，因此将应用程序与基础设施进行了解耦。\n* **可保持开发、测试和生产环境的一致性**：在笔记本上运行和放在云端运行效果是一样的。\n* **云端和操作系统的可移植性**:在Unbuntu、RHEL、CoreOS、on-prem、Google Container Engine以及其他地方随意运行。\n* **应用为核心的管理**：（相比于虚拟机的方式）抽象的层级由在虚拟硬件上运行操作系统提升到在操作系统上利用其逻辑资源直接运行应用程序。\n* **松耦合、弹性、分布式、微服务**: 应用被分为小型独立的片，可以动态进行部署和管理，无须在一个大的单一目的的主机上运行胖的程序栈。\n* **资源隔离**: 可预测的程序性能。\n* **资源利用最大化**: 高性能、高密度。\n\n## 为什么我需要Kubernetes，它能干什么\n\nKubernetes可以实现在物理集群或虚拟机集群上调度和运行容器，当然它还可以做得更多。\n\n为了充分发挥容器的优势并将传统的应用部署方式甩开，需要容器的部署与运行独立于基础设施。\n\n然而，当特定的容器不再与特定的主机绑定时，**主机为中心**的基础设施也不再适用：负载均衡、自动扩展等，因此需要**容器为中心**的架构，这便是kubernetes所提供的。\n\nKubernetes满足了应用程序在生产环境中的一些通用需求，例如：\n\n* [协同定位的辅助进程](http://kubernetes.io/docs/user-guide/pods/)，利用复杂应用部署，并且还保持了单容器单应用的模型。\n* [挂载存储系统](http://kubernetes.io/docs/user-guide/volumes/)\n* [分布式加密管理](http://kubernetes.io/docs/user-guide/secrets/)\n* [应用健康状况检查](http://kubernetes.io/docs/user-guide/production-pods/#liveness-and-readiness-probes-aka-health-checks)\n* [应用实例副本](http://kubernetes.io/docs/user-guide/replication-controller/)\n* [水平自动扩展](http://kubernetes.io/docs/user-guide/horizontal-pod-autoscaler/)\n* [命名与发现](http://kubernetes.io/docs/user-guide/connecting-applications/)\n* [负载均衡](http://kubernetes.io/docs/user-guide/services/)\n* [滚动升级](http://kubernetes.io/docs/user-guide/update-demo/)\n* [资源监控](http://kubernetes.io/docs/user-guide/monitoring/)\n* [日志的获取和注入](http://kubernetes.io/docs/user-guide/logging/)\n* [支持自省和调试](http://kubernetes.io/docs/user-guide/introspection-and-debugging/)以及，\n* [认证和授权](http://kubernetes.io/docs/admin/authorization/)\n\n上述功能提供了平台即服务(PaaS)的简易性以及基础设施即服务(IaaS)的灵活性，提升了跨基础设施移植的方便性。\n\n想得到更多细节内容，参加[用户指南](http://kubernetes.io/docs/user-guide/)\n\n## 为什么如何Kubernetes成为了一个平台\n\n尽管Kubernetes提供了很多功能，但总有新的应用场景需要新的特性，应用相关的工作流可流水线化以加速开发速度，最初设计的Ad hoc机制经常在扩展时需要更为灵活的自动化。这也是为什么Kubernetes被设计成为一个构建组件和工具生态的平台，使得应用的部署、扩展和管理更为容易。\n\n[标签](http://kubernetes.io/docs/user-guide/labels/)授权用户可以按需组织他们的资源，[标注功能](http://kubernetes.io/docs/user-guide/annotations/)能够使用户对特定的资源添加一些定制信息，以方便其工作流的实现，并且为管理工具的状态检查提供了一种解决方法。\n\n此外，[Kubernetes控制面板](http://kubernetes.io/docs/admin/cluster-components)是基于API进行构建的，这些[API](http://kubernetes.io/docs/api/)对于开发者和用户同样适用，用户可以基于此写出自己的控制器、[调度器](https://github.com/kubernetes/kubernetes/tree/release-1.2/docs/devel/scheduler.md)等，甚至可以有针对性的用[自己的API](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/extending-api.md)写一些通用的[命令行工具]()http://kubernetes.io/docs/user-guide/kubectl-overview/)\n\n这种[设计](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/principles.md)使得用户可以在Kubernetes基础上构建一些其他的系统。\n\n## Kubernetes并不是：\n\nKubernetes并不是传统意义包打天下的Paas系统，我们在一些重要的方面保留了用户选择的权利。\n\n* Kubernetes并不限制支持的应用类型，也不指定应用的框架（例如[Wildfly](http://wildfly.org/)），不限制支持的语言环境（例如：Java, Python, Ruby），并不迎合[12-factor application](http://12factor.net/)，也不是区分“应用”和“服务”。Kubernetes目的在于支持尽可能多样的负载，包括有状态、无状态、数据处理型的负载，只要应用程序可以运行在容器中，就可以很好地跑在Kubernetes。\n* Kubernetes不提供中间件（例如消息总线）、数据处理框架（如Spark）、数据库（如mysql），也不提供集群存储系统（如Ceph），这些应用运行在Kubernetes上。\n* Kubernetes没有点击即部署的服务前端。\n* Kubernetes并不提供源代码-镜像的处理空间，它并不部署源代码也不会构建你的应用，持续集成(Continuous Integration: CI)工作流要求用户和项目分别有自己的需求和选项，所以我们支持分层CI工作流，但是并不指定工作流该怎么工作。\n* Kubernetes允许用户自由选择日志、监视和告警系统。（尽管作为概念验证也提供了相应的集成）\n* Kubernetes并不提供也不指定一种综合的应用配置语言/系统（如[jsonnet](https://github.com/google/jsonnet)）。\n* Kubernetes并不提供也不采用任何综合的机器配置、维护、管理或自我修复系统。\n\n另一方面，很多PaaS系统运行在Kubernetes上，例如[Openshift](https://github.com/openshift/origin)、[Deis](http://deis.io/)以及[Gondor](https://gondor.io/)，你也可以定制你自己的Paas，整合一个CI系统，或者仅用Kubernetes也挺好，将容器镜像拿来直接部署到Kubernetes上。\n\n由于Kubernetes工作在应用层而不是仅在硬件层，它提供了一些一般Paas所能提供的通用特性，比如部署、扩展、负载均衡、日志和监控等，但Kubernetes并非一个整体，这些功能都是可选和可插拔的。\n\n此外，Kubernetes并不是一个业务流程系统，它消除了业务流程的需要，业务流程是指按照预定义的工作流执行任务，先A再B再C。相反，Kubernetes包含了一套独立、可组合的控制处理来连续驱动当前状态向所需状态转换，它不关心你怎么从A到C的。中央控制也并不需要，这种方法更像舞蹈，这使得系统更易于使用，也更强大、鲁棒、弹性和可扩展。\n\n## Kubernetes是什么意思？K8s？\n\n**Kubernetes**一词源自希腊语，意思是舵手或飞行员，并且是总督或控制论的根源。（The name Kubernetes originates from Greek, meaning “helmsman” or “pilot”, and is the root of “governor” and “cybernetic”）。K8s是将中间的8个字母用8来简写的结果。\n\n","source":"_posts/whatisk8s.md","raw":"title: 什么是kubernetes \ndate: 2016-03-17 12:58:01\ntags: Linux 云计算\n---\n\n【译者按】译自[kubernetes官网文档](http://kubernetes.io/docs/whatisk8s/)，主要介绍kubernetes的基本概念以及应用场景，K8s的设计理念，以及K8s能干什么不能干什么。\n\n# 什么是kubernetes?\nKubernetes是一款应用于集群的，[容器自动部署、扩展和管理的开源平台](http://www.slideshare.net/BrianGrant11/wso2con-us-2015-kubernetes-a-platform-for-automating-deployment-scaling-and-operations)，提供了一种以容器为中心的基础架构。\n\n利用kubernetes，你可以快速高效地响应客户如下请求：\n* 应用程序的动态、精准部署\n* 应用程序的动态扩展\n* 无缝推出新功能\n* 按需优化使用硬件资源\n\n我们的目标是提供一套减轻应用程序在公用云或私有云上运行负担的，生态环境的组件和工具。\n\n## kubernetes是：\n\n* 便携的：公有云、私有云、混合云、多云\n* 可扩展的：模块化、即插即用、钩子化、组合化\n* 自动修复的：自动布局、自动重启、自动副本、自动伸缩\n\nKubernetes项目是2014年由Google公司启动的，Kubernetes在[Google公司15年生产环境经验基础上](https://research.google.com/pubs/pub43438.html)，结合了社区的一些优秀点子和实践而构建的。\n\n准备好[开始了](http://kubernetes.io/docs/getting-started-guides/)吗？\n\n# 为什么要用容器\n\n寻找一下你用[容器](http://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/)理由？\n\n*传统方法*部署应用程序是利用操作系统的包管理器向主机上安装应用，这种方法的一个弊端是应用程序、配置、支撑库以及生命周期等经常与主机操作系统纠缠在一起，当然你也可以构建虚拟机镜像来实现可控的发布，但是虚拟机比较重量化并且其可移植性也不好。\n\n*新方法*部署容器则是基于操作系统级别的虚拟化而不是硬件层面的虚拟化实现的，这些容器相互之间以及容器与主机之间是隔离的：它们拥有自己的文件系统，共享运算资源，但它们彼此看不到对方。容器的构建也比虚拟机的构建要容易，由于它们不依赖于运行平台和文件系统，因此可以跨越云和操作系统发行版实现可移植性。\n\n因为容器小而快速，一个应用程序可以打包成容器镜像，这种应用与镜像的一一对应关系，彻底发挥了容器的好处。\n\n1. 永久的容器镜像可以在应用的开发阶段进行构建，而不是留在部署阶段，因为每个应用并不需要在其生命周期的其他阶段或是在正式交付生产环境时进行修改，这使得开发环境和生产环境高度一致。\n1. 容器相对于虚拟机更透明，便于监控和管理，特别是当容器的进程周期是由管理平台进行管理而不是由隐藏在容器中的超级进程进行管理时。\n1. 一个应用一个容器，对容器的管理相当于对应用的管理。\n\n容器的优点可以归结为:\n\n* **敏捷地进行应用构建和部署**: 相比于虚拟机的管理，容器的管理更为容易和高效。\n* **可连续进行开发、集成和部署**：采用快速回滚的方式，使其具备可靠和频繁的容器镜像构建和部署的能力（基于镜像的永久性）。\n* **开发和运维可分开考虑**：创建应用程序的容器镜像是在构建/发布阶段而不是在部署阶段，因此将应用程序与基础设施进行了解耦。\n* **可保持开发、测试和生产环境的一致性**：在笔记本上运行和放在云端运行效果是一样的。\n* **云端和操作系统的可移植性**:在Unbuntu、RHEL、CoreOS、on-prem、Google Container Engine以及其他地方随意运行。\n* **应用为核心的管理**：（相比于虚拟机的方式）抽象的层级由在虚拟硬件上运行操作系统提升到在操作系统上利用其逻辑资源直接运行应用程序。\n* **松耦合、弹性、分布式、微服务**: 应用被分为小型独立的片，可以动态进行部署和管理，无须在一个大的单一目的的主机上运行胖的程序栈。\n* **资源隔离**: 可预测的程序性能。\n* **资源利用最大化**: 高性能、高密度。\n\n## 为什么我需要Kubernetes，它能干什么\n\nKubernetes可以实现在物理集群或虚拟机集群上调度和运行容器，当然它还可以做得更多。\n\n为了充分发挥容器的优势并将传统的应用部署方式甩开，需要容器的部署与运行独立于基础设施。\n\n然而，当特定的容器不再与特定的主机绑定时，**主机为中心**的基础设施也不再适用：负载均衡、自动扩展等，因此需要**容器为中心**的架构，这便是kubernetes所提供的。\n\nKubernetes满足了应用程序在生产环境中的一些通用需求，例如：\n\n* [协同定位的辅助进程](http://kubernetes.io/docs/user-guide/pods/)，利用复杂应用部署，并且还保持了单容器单应用的模型。\n* [挂载存储系统](http://kubernetes.io/docs/user-guide/volumes/)\n* [分布式加密管理](http://kubernetes.io/docs/user-guide/secrets/)\n* [应用健康状况检查](http://kubernetes.io/docs/user-guide/production-pods/#liveness-and-readiness-probes-aka-health-checks)\n* [应用实例副本](http://kubernetes.io/docs/user-guide/replication-controller/)\n* [水平自动扩展](http://kubernetes.io/docs/user-guide/horizontal-pod-autoscaler/)\n* [命名与发现](http://kubernetes.io/docs/user-guide/connecting-applications/)\n* [负载均衡](http://kubernetes.io/docs/user-guide/services/)\n* [滚动升级](http://kubernetes.io/docs/user-guide/update-demo/)\n* [资源监控](http://kubernetes.io/docs/user-guide/monitoring/)\n* [日志的获取和注入](http://kubernetes.io/docs/user-guide/logging/)\n* [支持自省和调试](http://kubernetes.io/docs/user-guide/introspection-and-debugging/)以及，\n* [认证和授权](http://kubernetes.io/docs/admin/authorization/)\n\n上述功能提供了平台即服务(PaaS)的简易性以及基础设施即服务(IaaS)的灵活性，提升了跨基础设施移植的方便性。\n\n想得到更多细节内容，参加[用户指南](http://kubernetes.io/docs/user-guide/)\n\n## 为什么如何Kubernetes成为了一个平台\n\n尽管Kubernetes提供了很多功能，但总有新的应用场景需要新的特性，应用相关的工作流可流水线化以加速开发速度，最初设计的Ad hoc机制经常在扩展时需要更为灵活的自动化。这也是为什么Kubernetes被设计成为一个构建组件和工具生态的平台，使得应用的部署、扩展和管理更为容易。\n\n[标签](http://kubernetes.io/docs/user-guide/labels/)授权用户可以按需组织他们的资源，[标注功能](http://kubernetes.io/docs/user-guide/annotations/)能够使用户对特定的资源添加一些定制信息，以方便其工作流的实现，并且为管理工具的状态检查提供了一种解决方法。\n\n此外，[Kubernetes控制面板](http://kubernetes.io/docs/admin/cluster-components)是基于API进行构建的，这些[API](http://kubernetes.io/docs/api/)对于开发者和用户同样适用，用户可以基于此写出自己的控制器、[调度器](https://github.com/kubernetes/kubernetes/tree/release-1.2/docs/devel/scheduler.md)等，甚至可以有针对性的用[自己的API](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/extending-api.md)写一些通用的[命令行工具]()http://kubernetes.io/docs/user-guide/kubectl-overview/)\n\n这种[设计](https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/principles.md)使得用户可以在Kubernetes基础上构建一些其他的系统。\n\n## Kubernetes并不是：\n\nKubernetes并不是传统意义包打天下的Paas系统，我们在一些重要的方面保留了用户选择的权利。\n\n* Kubernetes并不限制支持的应用类型，也不指定应用的框架（例如[Wildfly](http://wildfly.org/)），不限制支持的语言环境（例如：Java, Python, Ruby），并不迎合[12-factor application](http://12factor.net/)，也不是区分“应用”和“服务”。Kubernetes目的在于支持尽可能多样的负载，包括有状态、无状态、数据处理型的负载，只要应用程序可以运行在容器中，就可以很好地跑在Kubernetes。\n* Kubernetes不提供中间件（例如消息总线）、数据处理框架（如Spark）、数据库（如mysql），也不提供集群存储系统（如Ceph），这些应用运行在Kubernetes上。\n* Kubernetes没有点击即部署的服务前端。\n* Kubernetes并不提供源代码-镜像的处理空间，它并不部署源代码也不会构建你的应用，持续集成(Continuous Integration: CI)工作流要求用户和项目分别有自己的需求和选项，所以我们支持分层CI工作流，但是并不指定工作流该怎么工作。\n* Kubernetes允许用户自由选择日志、监视和告警系统。（尽管作为概念验证也提供了相应的集成）\n* Kubernetes并不提供也不指定一种综合的应用配置语言/系统（如[jsonnet](https://github.com/google/jsonnet)）。\n* Kubernetes并不提供也不采用任何综合的机器配置、维护、管理或自我修复系统。\n\n另一方面，很多PaaS系统运行在Kubernetes上，例如[Openshift](https://github.com/openshift/origin)、[Deis](http://deis.io/)以及[Gondor](https://gondor.io/)，你也可以定制你自己的Paas，整合一个CI系统，或者仅用Kubernetes也挺好，将容器镜像拿来直接部署到Kubernetes上。\n\n由于Kubernetes工作在应用层而不是仅在硬件层，它提供了一些一般Paas所能提供的通用特性，比如部署、扩展、负载均衡、日志和监控等，但Kubernetes并非一个整体，这些功能都是可选和可插拔的。\n\n此外，Kubernetes并不是一个业务流程系统，它消除了业务流程的需要，业务流程是指按照预定义的工作流执行任务，先A再B再C。相反，Kubernetes包含了一套独立、可组合的控制处理来连续驱动当前状态向所需状态转换，它不关心你怎么从A到C的。中央控制也并不需要，这种方法更像舞蹈，这使得系统更易于使用，也更强大、鲁棒、弹性和可扩展。\n\n## Kubernetes是什么意思？K8s？\n\n**Kubernetes**一词源自希腊语，意思是舵手或飞行员，并且是总督或控制论的根源。（The name Kubernetes originates from Greek, meaning “helmsman” or “pilot”, and is the root of “governor” and “cybernetic”）。K8s是将中间的8个字母用8来简写的结果。\n\n","slug":"whatisk8s","published":1,"updated":"2016-03-17T14:22:52.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsd0009aziy9ebzksdh"},{"title":"理解Docker","date":"2014-10-31T14:16:39.000Z","_content":"\n原文出自https://docs.docker.com/introduction/understanding-docker/， 本文由<deerlux@163.com>翻译。\n\n什么是Docker？\n=============\n\nDocker是一个用于开发、装载和运行程度的开放平台，可使你的程序迁移更加便捷。在Docker中可以将你的应用程序和基础设施层隔离，并且还可以将你的基础设施当作程序一样进行管理。Docker可以帮助你更加快速地打包你代码、更加快速地测试、更加快速地部署，并且可以减少写代码到部署运行代码的周期。\n\nDocker通过将一个轻量级的容器虚拟化平台和一组标准工作流程、工具进行集成，来帮助你方便地管理和部署应用。\n\n核心的是，Docker提供了一种在一个安全隔离的环境中运行几乎所有程序方式，这种隔离性和安全性允许你在同一主机上同时运行多个容器，而容器的这种轻量级特性，意味着你可以节省更多的硬件资源，因为你不必消耗运行hypervisor所需要的额外负载的。\n\n围绕容器虚拟化Docker提供了一些工具和一个平台，可为你提供以下帮助：\n\n* 将应用程序（包括支撑的组件）放入docker容器中；\n* 将这些容器打包并分发给你的团队，以便于后续的开发和测试；\n* 将这些容器部署到生产环境中，即可以是本地的数据中心也可以在云端。\n\n我可以用Docker做些什么？\n======================\n\n快速分发你的应用\n----------------\n\nDocker是开发过程中较为理想的助手，它允许你在包含了你的应用和服务的本地容器中进行开发，然后帮你完成集成和部署。\n\n例如，你的开发人员可以在本地写代码然后通过Docker与其他同事共享，当他们完成了各自的开发任务后，可以将他们的代码推送到一个测试的环境中进行测试，完成测试后便可以将相应的Docker镜像部署到生产环境中。\n\n更方便地进行部署和调整规模\n----------------------\n\nDocker这种基于容器的平台具有高度的便携性，它可以无缝地运行于开发者的本地主机、数据中心其他的物理机或虚拟机、或者云端。\n\nDocker的便携性和其天然的轻量特性易于实现动态地负载管理，你可以利用Docker快速地增减应用和服务的部署规模，Docker的速度保证了这种规模的调整近乎实时。\n\n更高密度的部署应用和运行更多的应用\n----------------------------------\n\n由于Docker轻量并且快速，因此相对于基于Hypervisor的虚拟机的部署方式，Docker提供了一种更可行和划算的替代方案，这对于高密度部署环境尤其有用，例如在构建私有云或平台即服务环境时，当然，当你想在有限的资源里部署更多的应用时，Docker对于小中型的部署也非常有用。\n\nDocker主要包括哪些组件？\n======================\n\nDocker主要包括两个组件：\n\n* Docker: 开源的容器虚拟化平台；\n* [Docker Hub](https://hub.docker.com/) ：用于分享和管理Docker容器的软件即服务平台。\n\n**注**: Docker在Apache 2.0开源协议下进行授权。\n\nDocker的架构？\n==============\n\nDocker是一种Client/Server的架构，Docker客户端与Docker daemon进行交互，daemon负责构建、运行和发布Docker容器。客户端即可以和服务端运行在同一个系统中，也可以连接远程的daemon。Docker的客户端的daemon通过RESTful API进行sockets 通信。\n\n![docker-architecture.svg](https://docs.docker.com/article-img/architecture.svg)\n\nDocker守护进程\n--------------\n\n就像上图所示，Docker守护进程(daemon)在主机上运行，用户不能直接和守护进程打交道，但是可以通过docker客户端与其进行交互。\n\nDocker客户端\n------------\n\nDocker客户端——`docker`二进制文件的功能之一——是Docker的初始用户界面，它接收用户的命令并反馈，并且与Docker的守护进行交互。\n\nDocker内部机制\n--------------\n\n理解Docker的内部机制，你需要明白如下三个组件：\n\n* Docker镜像\n* Docker注册中心\n* Docker容器\n\n### Docker镜像\n\n\nDocker镜像是一个只读的模块。例如，一个镜像可以包含一个安装了apache WEB服务应用的Ubuntu操作系统。镜像用来创建Docker容器。Docker提供了构建新镜像或升级原有镜像的较为便利的方式，或者你也可以下载别人已经创建好的镜像。Docker镜像是Docker的**构建**组件。\n\n### Docker注册中心\n\nDocker注册中心用于上传和下载镜像，有公共注册中心和私有注册中心两种。公共注册中心为[Docker Hub](https://hub.docker.com/)，它提供了大量的现成镜像，你可以构建自己的镜像上传到上面，也可以在上面下载别人构建的镜像。Docker注册中心是Docker的**发布**组件。\n\n### Docker容器\n\nDocker容器与一个目录很类似，它包含了一个应用程序运行所需要的一切内容。每个容器都是基于一个Docker镜像制作的。Docker容器可被运行、开始、停止、迁移或者是删除。每个容器均是一个隔离的、安全的应用平台。Docker容器是Docker的**运行**组件。\n\nDocker怎样工作的\n-----------------\n\n至此，我们已经知道了：\n\n1. 你可以构建用于存储你的应用程序的镜像；\n1. 你可以从Docker镜像中创建容器用来运行你的应用；\n1. 你可以通过[Docker Hub](https://hub.docker.com/)或者你自己的注册中心来共享Docker镜像\n\n\n那我们看看Docker是怎么将这些元素组合在一起工作的。\n\n### Docker镜像是如何工作的\n\n我们已经知道Docker镜像实质上是一些用于加载Docker容器的只读模板，每个镜像包括很多层。Docker利用[union file systems](http://en.wikipedia.org/wiki/UnionFS)将这些层组合为一个镜像。Union file systems允许相互隔离的文件或目录透明的叠加在一起，而呈现为一个统一的文件系统。\n\nDocker如此轻量化的原因也是由于这些层的存在。当你对一个Docker镜像进行修改时——例如将一个应用升级为一个新的版本——会构建一个新的层，因此，与虚拟机的替换整个镜像或完全构建的方式不同，Docker仅对相关的层进行添加或升级。所以你仅需要发布镜像的更新部分而不必发布整个镜像，这种方式使得镜像的发布更加快速和简单。\n\n每个镜像始于一个基础镜像，例如：`ubuntu`便是一个基础的Ubuntu镜像，`fedora`是一个基础的Fedora镜像。你也可以将你自己制作的镜像作为基础镜像，例如你可以将一个Apache镜像作为一个Web应用的基础镜像。\n\n> 注意：Docker一般从[Docker Hub](https://hub.docker.com/)上获取基础镜像。\n\nDocker镜像从这些基础镜像中按照一系列的步骤进行制作，我们称这些步骤为**指令**，每个指令在你的镜像中创建一个新的层，指令包括以下行为：\n\n* 运行一条命令；\n* 添加一个文件或目录；\n* 创建一个环境变量；\n* 从此镜像中加载一个容器时需要运行的进程。\n\n这些指令存储在`Dockerfile`中，Docker在构建镜像过程中读取这个`Dockerfile`，运行里面的指令并返回最终的镜像。\n\n### Docker注册中心如何工作的\n\nDocker注册中心是Docker镜像的存储中心，当你构建完一个镜像后便可以将其推送到[Docker Hub](https://hub.docker.com)或你自己的注册中心。\n\n利用Docker客户端，你可以搜索已经发布的镜像，然后将其拉取到你的Docker主机上，以便于从这些镜像中构建容器。\n\n[Docker Hub](https://hub.docker.com)为镜像提供了公共的和私有的存储空间。公共的存储空间任何人均可以在上面搜索和下载，私有存储空间仅对你本人或你的团队开放搜索以及拉取下载，你可以通过[这里](https://hub.docker.com/plans)注册一个私有的存储空间。\n\n### 容器是如何工作的\n\n一个容器包括操作系统、用户添加的文件以及相关的元数据。我们知道，每个容器都是从镜像中构建出来的，这个镜像告诉Docker容器用到什么资源、当容器加载时启动哪个进程以及容器启动时的其他配置。Docker镜像是只读的，当Docker从一个镜像运行一个容器时，它会在镜像的上层添加一个用于运行应用的可读写的层（利用的就是上文提到的union file system）。\n\n### 运行一个容器时到底发生了什么\n\nDocker客户端通过直接运行`docker`或者通过API调用的方式，可以通知Docker的守护进程运行一个容器。\n\n``` shell\n$ sudo docker run -i -t ubuntu /bin/bash\n```\n\n我们来看一下这个命令，Docker客户端利用`docker`命令跟一个`run`的选项启动一个容器，一个最小配置的Docker客户端运行一个容器需要告诉Docker守护进程以下事项：\n\n* 此容器基于什么镜像来构建，此处是`ubuntu`——一个基础的Ubuntu镜像；\n* 需要在容器中运行的命令，此处是`/bin/bash`——在容器中启动一个Bash Shell。\n\n那么我们看看运行上述命令时到底发生了什么？\n\n按照顺序，Docker依次干了如下事情：\n\n* **拉取`ubuntu`镜像** : Docker首先检查一下`ubuntu`镜像在本地服务器上存不存在，如果不存在，则自动从[Docker Hub](https://hub.docker.com/)中下载，如果已经存在则直接利用这个镜像来启动一个新的容器。\n* **创建一个新的容器**: 如果Docker本地服务器中存在这个镜像，那么就据此来启动一个容器。\n* **分配一个文件每户并且将其挂载到一个可读写的层**: 容器在此文件系统中被创建，并且将其作为一个可读写的层添加到镜像中。\n* **分配一个网络或桥接的接口**: 创建一个网络的接口以便于Docker容器能够访问本机。\n* **设置一个IP地址**: 为此容器从地址池中找到并绑定一个IP地址。\n* **执行指定的进程**: 运行你的应用程序，然后；\n* **获取并提供应用程序的输出**: 连接标准输入、标准输出和标准错误接口，这样你便可以观察到程序运行的一切。\n\n现在你已经运行了一个容器，这样你便可以管理你的容器、与应用程序进行交互，当运行结束是停止或者删除你的容器。\n\n## 底层技术问题\n\nDocker是用Go语言实现的，用到了一些Linux内核的特性实现上述功能。\n\n### 命名空间（namespaces）\n\nDocker在为容器提供一个隔离的工作空间时，用到了`命名空间`的技术，当你运行一个容器时，Docker会为此容器创建一组命名空间。\n\n这样便可以提供一个隔离的层：每个容器运行在自己的命名空间中，而外部不能访问这个层。\n\nDocker用到的一些命名空间有：\n\n* **`pid`命名空间**: 用于隔离进程（PID：Process ID）；\n* **`net`命名空间**: 用于管理网络；\n* **`ipc`命名空间**: 用于访问IPC资源（IPC：InterProcess Communication）；\n* **`mnt`命名空间**: 用于管理挂载点（MNT：Mount）；\n* **`uts`命名空间**: 用于隔离内核和版本标识（UTS：Unix Timesharing System）。\n\n### 控制组（Control Groups）\n\nDocker还用到了另外一项技术叫`cgroups`或者叫控制组（control groups）。实现程序运行环境的隔离的关键在于使这些程序只用到他们需要的资源，这就能够保证这些容器是主机服务环境小社会中的好市民。控制组允许Docker在不同的容器之间共享硬件资源，需要时添加一些限制和约束，例如限制一个容器最大访问内存量。\n\n### 统一文件系统（Union file systems）\n\n统一文件系统或者说是UnionFS，是创建层的时候用到的文件系统，使文件系统非常轻量和快速。Docker使用统一文件系统为容器构建blocks，Docker可以使用几种不同的文件系统：AUFS、btrfs、vfs以及DeviceMapper。\n\n### 容器格式\n\nDocker容器将这些组件合并在一起，我们称之为容器格式，容器的缺省格式称为`libcontainer`。Docker还支持利用[LXC](https://linuxcontainers.org/)技术的传统Linux容器格式，未来还将会支持其他的容器格式，例如：与BSD Jails或者Solaris Zones实现整合。\n\n# 下一步\n\n安装Docker，请参照[installation section](https://docs.docker.com/installation/#installation)\n\nDocker用户指南，请参照[深入学习Docker](https://docs.docker.com/userguide/)\n\n\n\n\n\n\n\n\n","source":"_posts/understanding-docker.md","raw":"title: 理解Docker \ndate: 2014-10-31 22:16:39\ntags: 虚拟化\n---\n\n原文出自https://docs.docker.com/introduction/understanding-docker/， 本文由<deerlux@163.com>翻译。\n\n什么是Docker？\n=============\n\nDocker是一个用于开发、装载和运行程度的开放平台，可使你的程序迁移更加便捷。在Docker中可以将你的应用程序和基础设施层隔离，并且还可以将你的基础设施当作程序一样进行管理。Docker可以帮助你更加快速地打包你代码、更加快速地测试、更加快速地部署，并且可以减少写代码到部署运行代码的周期。\n\nDocker通过将一个轻量级的容器虚拟化平台和一组标准工作流程、工具进行集成，来帮助你方便地管理和部署应用。\n\n核心的是，Docker提供了一种在一个安全隔离的环境中运行几乎所有程序方式，这种隔离性和安全性允许你在同一主机上同时运行多个容器，而容器的这种轻量级特性，意味着你可以节省更多的硬件资源，因为你不必消耗运行hypervisor所需要的额外负载的。\n\n围绕容器虚拟化Docker提供了一些工具和一个平台，可为你提供以下帮助：\n\n* 将应用程序（包括支撑的组件）放入docker容器中；\n* 将这些容器打包并分发给你的团队，以便于后续的开发和测试；\n* 将这些容器部署到生产环境中，即可以是本地的数据中心也可以在云端。\n\n我可以用Docker做些什么？\n======================\n\n快速分发你的应用\n----------------\n\nDocker是开发过程中较为理想的助手，它允许你在包含了你的应用和服务的本地容器中进行开发，然后帮你完成集成和部署。\n\n例如，你的开发人员可以在本地写代码然后通过Docker与其他同事共享，当他们完成了各自的开发任务后，可以将他们的代码推送到一个测试的环境中进行测试，完成测试后便可以将相应的Docker镜像部署到生产环境中。\n\n更方便地进行部署和调整规模\n----------------------\n\nDocker这种基于容器的平台具有高度的便携性，它可以无缝地运行于开发者的本地主机、数据中心其他的物理机或虚拟机、或者云端。\n\nDocker的便携性和其天然的轻量特性易于实现动态地负载管理，你可以利用Docker快速地增减应用和服务的部署规模，Docker的速度保证了这种规模的调整近乎实时。\n\n更高密度的部署应用和运行更多的应用\n----------------------------------\n\n由于Docker轻量并且快速，因此相对于基于Hypervisor的虚拟机的部署方式，Docker提供了一种更可行和划算的替代方案，这对于高密度部署环境尤其有用，例如在构建私有云或平台即服务环境时，当然，当你想在有限的资源里部署更多的应用时，Docker对于小中型的部署也非常有用。\n\nDocker主要包括哪些组件？\n======================\n\nDocker主要包括两个组件：\n\n* Docker: 开源的容器虚拟化平台；\n* [Docker Hub](https://hub.docker.com/) ：用于分享和管理Docker容器的软件即服务平台。\n\n**注**: Docker在Apache 2.0开源协议下进行授权。\n\nDocker的架构？\n==============\n\nDocker是一种Client/Server的架构，Docker客户端与Docker daemon进行交互，daemon负责构建、运行和发布Docker容器。客户端即可以和服务端运行在同一个系统中，也可以连接远程的daemon。Docker的客户端的daemon通过RESTful API进行sockets 通信。\n\n![docker-architecture.svg](https://docs.docker.com/article-img/architecture.svg)\n\nDocker守护进程\n--------------\n\n就像上图所示，Docker守护进程(daemon)在主机上运行，用户不能直接和守护进程打交道，但是可以通过docker客户端与其进行交互。\n\nDocker客户端\n------------\n\nDocker客户端——`docker`二进制文件的功能之一——是Docker的初始用户界面，它接收用户的命令并反馈，并且与Docker的守护进行交互。\n\nDocker内部机制\n--------------\n\n理解Docker的内部机制，你需要明白如下三个组件：\n\n* Docker镜像\n* Docker注册中心\n* Docker容器\n\n### Docker镜像\n\n\nDocker镜像是一个只读的模块。例如，一个镜像可以包含一个安装了apache WEB服务应用的Ubuntu操作系统。镜像用来创建Docker容器。Docker提供了构建新镜像或升级原有镜像的较为便利的方式，或者你也可以下载别人已经创建好的镜像。Docker镜像是Docker的**构建**组件。\n\n### Docker注册中心\n\nDocker注册中心用于上传和下载镜像，有公共注册中心和私有注册中心两种。公共注册中心为[Docker Hub](https://hub.docker.com/)，它提供了大量的现成镜像，你可以构建自己的镜像上传到上面，也可以在上面下载别人构建的镜像。Docker注册中心是Docker的**发布**组件。\n\n### Docker容器\n\nDocker容器与一个目录很类似，它包含了一个应用程序运行所需要的一切内容。每个容器都是基于一个Docker镜像制作的。Docker容器可被运行、开始、停止、迁移或者是删除。每个容器均是一个隔离的、安全的应用平台。Docker容器是Docker的**运行**组件。\n\nDocker怎样工作的\n-----------------\n\n至此，我们已经知道了：\n\n1. 你可以构建用于存储你的应用程序的镜像；\n1. 你可以从Docker镜像中创建容器用来运行你的应用；\n1. 你可以通过[Docker Hub](https://hub.docker.com/)或者你自己的注册中心来共享Docker镜像\n\n\n那我们看看Docker是怎么将这些元素组合在一起工作的。\n\n### Docker镜像是如何工作的\n\n我们已经知道Docker镜像实质上是一些用于加载Docker容器的只读模板，每个镜像包括很多层。Docker利用[union file systems](http://en.wikipedia.org/wiki/UnionFS)将这些层组合为一个镜像。Union file systems允许相互隔离的文件或目录透明的叠加在一起，而呈现为一个统一的文件系统。\n\nDocker如此轻量化的原因也是由于这些层的存在。当你对一个Docker镜像进行修改时——例如将一个应用升级为一个新的版本——会构建一个新的层，因此，与虚拟机的替换整个镜像或完全构建的方式不同，Docker仅对相关的层进行添加或升级。所以你仅需要发布镜像的更新部分而不必发布整个镜像，这种方式使得镜像的发布更加快速和简单。\n\n每个镜像始于一个基础镜像，例如：`ubuntu`便是一个基础的Ubuntu镜像，`fedora`是一个基础的Fedora镜像。你也可以将你自己制作的镜像作为基础镜像，例如你可以将一个Apache镜像作为一个Web应用的基础镜像。\n\n> 注意：Docker一般从[Docker Hub](https://hub.docker.com/)上获取基础镜像。\n\nDocker镜像从这些基础镜像中按照一系列的步骤进行制作，我们称这些步骤为**指令**，每个指令在你的镜像中创建一个新的层，指令包括以下行为：\n\n* 运行一条命令；\n* 添加一个文件或目录；\n* 创建一个环境变量；\n* 从此镜像中加载一个容器时需要运行的进程。\n\n这些指令存储在`Dockerfile`中，Docker在构建镜像过程中读取这个`Dockerfile`，运行里面的指令并返回最终的镜像。\n\n### Docker注册中心如何工作的\n\nDocker注册中心是Docker镜像的存储中心，当你构建完一个镜像后便可以将其推送到[Docker Hub](https://hub.docker.com)或你自己的注册中心。\n\n利用Docker客户端，你可以搜索已经发布的镜像，然后将其拉取到你的Docker主机上，以便于从这些镜像中构建容器。\n\n[Docker Hub](https://hub.docker.com)为镜像提供了公共的和私有的存储空间。公共的存储空间任何人均可以在上面搜索和下载，私有存储空间仅对你本人或你的团队开放搜索以及拉取下载，你可以通过[这里](https://hub.docker.com/plans)注册一个私有的存储空间。\n\n### 容器是如何工作的\n\n一个容器包括操作系统、用户添加的文件以及相关的元数据。我们知道，每个容器都是从镜像中构建出来的，这个镜像告诉Docker容器用到什么资源、当容器加载时启动哪个进程以及容器启动时的其他配置。Docker镜像是只读的，当Docker从一个镜像运行一个容器时，它会在镜像的上层添加一个用于运行应用的可读写的层（利用的就是上文提到的union file system）。\n\n### 运行一个容器时到底发生了什么\n\nDocker客户端通过直接运行`docker`或者通过API调用的方式，可以通知Docker的守护进程运行一个容器。\n\n``` shell\n$ sudo docker run -i -t ubuntu /bin/bash\n```\n\n我们来看一下这个命令，Docker客户端利用`docker`命令跟一个`run`的选项启动一个容器，一个最小配置的Docker客户端运行一个容器需要告诉Docker守护进程以下事项：\n\n* 此容器基于什么镜像来构建，此处是`ubuntu`——一个基础的Ubuntu镜像；\n* 需要在容器中运行的命令，此处是`/bin/bash`——在容器中启动一个Bash Shell。\n\n那么我们看看运行上述命令时到底发生了什么？\n\n按照顺序，Docker依次干了如下事情：\n\n* **拉取`ubuntu`镜像** : Docker首先检查一下`ubuntu`镜像在本地服务器上存不存在，如果不存在，则自动从[Docker Hub](https://hub.docker.com/)中下载，如果已经存在则直接利用这个镜像来启动一个新的容器。\n* **创建一个新的容器**: 如果Docker本地服务器中存在这个镜像，那么就据此来启动一个容器。\n* **分配一个文件每户并且将其挂载到一个可读写的层**: 容器在此文件系统中被创建，并且将其作为一个可读写的层添加到镜像中。\n* **分配一个网络或桥接的接口**: 创建一个网络的接口以便于Docker容器能够访问本机。\n* **设置一个IP地址**: 为此容器从地址池中找到并绑定一个IP地址。\n* **执行指定的进程**: 运行你的应用程序，然后；\n* **获取并提供应用程序的输出**: 连接标准输入、标准输出和标准错误接口，这样你便可以观察到程序运行的一切。\n\n现在你已经运行了一个容器，这样你便可以管理你的容器、与应用程序进行交互，当运行结束是停止或者删除你的容器。\n\n## 底层技术问题\n\nDocker是用Go语言实现的，用到了一些Linux内核的特性实现上述功能。\n\n### 命名空间（namespaces）\n\nDocker在为容器提供一个隔离的工作空间时，用到了`命名空间`的技术，当你运行一个容器时，Docker会为此容器创建一组命名空间。\n\n这样便可以提供一个隔离的层：每个容器运行在自己的命名空间中，而外部不能访问这个层。\n\nDocker用到的一些命名空间有：\n\n* **`pid`命名空间**: 用于隔离进程（PID：Process ID）；\n* **`net`命名空间**: 用于管理网络；\n* **`ipc`命名空间**: 用于访问IPC资源（IPC：InterProcess Communication）；\n* **`mnt`命名空间**: 用于管理挂载点（MNT：Mount）；\n* **`uts`命名空间**: 用于隔离内核和版本标识（UTS：Unix Timesharing System）。\n\n### 控制组（Control Groups）\n\nDocker还用到了另外一项技术叫`cgroups`或者叫控制组（control groups）。实现程序运行环境的隔离的关键在于使这些程序只用到他们需要的资源，这就能够保证这些容器是主机服务环境小社会中的好市民。控制组允许Docker在不同的容器之间共享硬件资源，需要时添加一些限制和约束，例如限制一个容器最大访问内存量。\n\n### 统一文件系统（Union file systems）\n\n统一文件系统或者说是UnionFS，是创建层的时候用到的文件系统，使文件系统非常轻量和快速。Docker使用统一文件系统为容器构建blocks，Docker可以使用几种不同的文件系统：AUFS、btrfs、vfs以及DeviceMapper。\n\n### 容器格式\n\nDocker容器将这些组件合并在一起，我们称之为容器格式，容器的缺省格式称为`libcontainer`。Docker还支持利用[LXC](https://linuxcontainers.org/)技术的传统Linux容器格式，未来还将会支持其他的容器格式，例如：与BSD Jails或者Solaris Zones实现整合。\n\n# 下一步\n\n安装Docker，请参照[installation section](https://docs.docker.com/installation/#installation)\n\nDocker用户指南，请参照[深入学习Docker](https://docs.docker.com/userguide/)\n\n\n\n\n\n\n\n\n","slug":"understanding-docker","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsf000caziys356ebzg"},{"title":"sqlalchemy的简单用法","date":"2014-10-23T13:43:47.000Z","_content":"\n数据库中表结构是现成的情况下ORM\n--------------------------------\n\n前几天想自己在网上抓些东西然后存放在数据库中以便于后续的数据分析，只是不想自己\n用DB-API写SQL语句去操作数据，所以才想用ORM的方式，可是看了半天sqlalchemy的文档\n，都是在讲如何进行建库、建关系等，可是问题是我们经常要操作的数据库，库表的建立\n并不是通过ORM的方式建，更希望是通过原始的SQL语句去建，对一个现成的数据库进行ORM\n方式访问有没有更方便的方法呢？这种情况下有没有一种更方便的方式去访问数据库？答\n案当然是肯定的。\n\n比如我用来存储用户信息的sqlite数据库 (test.db) 结构是这样的：\n\n``` sql\ncreate table if not exists users (\n    id integer primary key,\n    name varchar(20),\n    password varchar(20)\n);\n```\n\nsqlalchemy 0.9.1 之后增加了一种automap_base的机制，可以使现成的数据库中的数据结\n构反射到类上。用来访问上述数据库中的表只需要简单几句就可以完成映射：\n\n``` python\n# -*- coding=utf-8 -*-\nimport sqlalchemy\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.ext.automap import automap_base\n\nif __name__ == \"__main__\":\n    engine_str = 'sqlite:///:test.db'\n    engine = sqlalchemy.create_engine(engine_str)\n\n    session = Session(engine)\n\n    # 下面这两句话就完成了ORM映射 Base.classes.XXXX即为映射的类\n    # Base.metadata.tables['XXX']即为相应的表\n    Base = automap_base()\n    Base.prepare(engine, reflect = True)\n\n    # 查询操作\n    result = session.query(Base.classes.users).all()\n\n    # 插入操作\n    item = Base.classes.users(name='lxq', password='1234')\n    session.add(item)\n    session.commit()\n    \n    session.close()\n```\n\n简单定义了两个类之后，不用关心数据表的内部实现，sqlalchemy会实现自动的映射，随\n后手册上的很多操作都可以正常使用了。\n\n数据的修改\n----------\n\nORM系统对数据库中访问到的每一行数据会映射为一个唯一的Table对象，因此，当需要对\n数据修改的时候，找到这行数据然后直接改其元素然后commit即可。\n\n``` python\ned_user = session.query(User).filter_by(name='ed').first()\ned_user.name = 'love'\nsession.commit()\n```\n\n批量插入\n--------\n\n利用单纯的ORM方式进行大批量的插入数据，由于是调用多条INSERT语句，因此效率十分低\n下，session.add_all函数实际上也是调用了多条INSERT语句，如果想批量插入数据，可以\n进行如下处理：\n\n``` python\nengine.execute(User.__table__.insert(), \n    [{'name':'hello', 'password':'1234'},\n    {'name':'hello2', 'password':'1234'}])\n```\n\nMISC\n-----\n\nLazy connecting\n~~~~~~~~~~~~~~~~\n\ncreate_engine 按照手册上的说法是lazy_connecting，当你在create_engine的时候并不\n会真正的建立数据库连接，而当第一次进行数据库相关操作的时候才会真正建立连接。\n\n\n","source":"_posts/sqlalchemy.md","raw":"title: sqlalchemy的简单用法\ndate: 2014-10-23 21:43:47\ntags: Python\n---\n\n数据库中表结构是现成的情况下ORM\n--------------------------------\n\n前几天想自己在网上抓些东西然后存放在数据库中以便于后续的数据分析，只是不想自己\n用DB-API写SQL语句去操作数据，所以才想用ORM的方式，可是看了半天sqlalchemy的文档\n，都是在讲如何进行建库、建关系等，可是问题是我们经常要操作的数据库，库表的建立\n并不是通过ORM的方式建，更希望是通过原始的SQL语句去建，对一个现成的数据库进行ORM\n方式访问有没有更方便的方法呢？这种情况下有没有一种更方便的方式去访问数据库？答\n案当然是肯定的。\n\n比如我用来存储用户信息的sqlite数据库 (test.db) 结构是这样的：\n\n``` sql\ncreate table if not exists users (\n    id integer primary key,\n    name varchar(20),\n    password varchar(20)\n);\n```\n\nsqlalchemy 0.9.1 之后增加了一种automap_base的机制，可以使现成的数据库中的数据结\n构反射到类上。用来访问上述数据库中的表只需要简单几句就可以完成映射：\n\n``` python\n# -*- coding=utf-8 -*-\nimport sqlalchemy\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.ext.automap import automap_base\n\nif __name__ == \"__main__\":\n    engine_str = 'sqlite:///:test.db'\n    engine = sqlalchemy.create_engine(engine_str)\n\n    session = Session(engine)\n\n    # 下面这两句话就完成了ORM映射 Base.classes.XXXX即为映射的类\n    # Base.metadata.tables['XXX']即为相应的表\n    Base = automap_base()\n    Base.prepare(engine, reflect = True)\n\n    # 查询操作\n    result = session.query(Base.classes.users).all()\n\n    # 插入操作\n    item = Base.classes.users(name='lxq', password='1234')\n    session.add(item)\n    session.commit()\n    \n    session.close()\n```\n\n简单定义了两个类之后，不用关心数据表的内部实现，sqlalchemy会实现自动的映射，随\n后手册上的很多操作都可以正常使用了。\n\n数据的修改\n----------\n\nORM系统对数据库中访问到的每一行数据会映射为一个唯一的Table对象，因此，当需要对\n数据修改的时候，找到这行数据然后直接改其元素然后commit即可。\n\n``` python\ned_user = session.query(User).filter_by(name='ed').first()\ned_user.name = 'love'\nsession.commit()\n```\n\n批量插入\n--------\n\n利用单纯的ORM方式进行大批量的插入数据，由于是调用多条INSERT语句，因此效率十分低\n下，session.add_all函数实际上也是调用了多条INSERT语句，如果想批量插入数据，可以\n进行如下处理：\n\n``` python\nengine.execute(User.__table__.insert(), \n    [{'name':'hello', 'password':'1234'},\n    {'name':'hello2', 'password':'1234'}])\n```\n\nMISC\n-----\n\nLazy connecting\n~~~~~~~~~~~~~~~~\n\ncreate_engine 按照手册上的说法是lazy_connecting，当你在create_engine的时候并不\n会真正的建立数据库连接，而当第一次进行数据库相关操作的时候才会真正建立连接。\n\n\n","slug":"sqlalchemy","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsh000faziyeuk3zg1n"},{"title":"openshift云平台注册使用","date":"2016-04-01T00:31:30.000Z","_content":"【编者按】一直想申请一个免费的托管空间，国内找了一圈sinaapp还算差强人意，但是对于python不以安装C extension的包，而且SAE的一整套流程用起来感觉很不爽，而openshift的平台的工作流更适合一般开发人员的思维模式（我是针对Python，其他语言没有试过没有发言权），鉴于国内关注得还比较少，我把自己注册到开发的经验记录下来，希望对需要的人有所帮助。\n\n# Openshift简介\n\nOpenshift是RedHat公司的一款平台云产品，openshift.com是由RedHat公司维护的一个公有平台云服务平台，提供基础的语言环境、数据库以及其他运维相关的环境。用git实现自动部署，免费用户可以得到1GB的空间，流量无限制。因为RedHat服务器在国外，访问国外的网站速度也会有优势。特别是管理端，可以通过ssh直接登录上去进行调试管理，使用十分方便。语言方面，支持Java、Python、Ruby、Perl、PHP、Node.js等主流的编程语言。\n\n缺点嘛，国外的网站，管理端访问速度确实有点慢，做出来网站的访问速度感觉还可以，当然现在我做的规模还比较小，但对于个人做点事情（比如爬虫）感觉还是可以的。\n\n# Openshift注册及新建应用\n\n## 注册用户\n\n到[Openshift官网](https://www.openshift.com/)点SIGN UP FOR FREE，不过，那个验证码是从google取的，不翻墙的话看不到验证码，不过仅注册的这一次验证码，注册完再登录不需要翻墙便可以正常登录。\n\n![注册界面](openshift_signin.png)\n\n注册可能会发你一封验证邮件，点一下验证邮件里的链接即完成注册，然后便可以用此用户登录使用了。\n\n## 创建新的应用\n\n用你刚注册的用户登录，到 http://www.openshift.com 点击右上角MY ACCOUNT里的WEB CONSOLE菜单登录。登录上去可以看到你的控制台，点击下面的Add Application按钮即可新建一个应用：\n\n![新建应用](openshift_add.png)\n\n点击完后需要你选择应用的类型，比如你可以选择python2.7，当然你也可以选择python3.3，选择完后会让先让你给应用起个名称，名称都会加上你的用户名后缀。\n\n![输入应用相关信息](openshift_appname.png)\n\n其它的选项暂时可以不用改，点击最下面的Create Application按钮，这个应用便是创建完成了。每个免费的用户可以创建3个应用，每个应用1GB的存储空间，包括数据库和语言相关包以及你的所有的程序文件共享这1GB的空间。点完Create Application后可以看到一些提示信息，不管它直接Continue即可。\n\n![Continue](openshift_appnext.png)\n\n服务端会给你的应用建立一个python的virtualenv，你的程序在此virtualenv中运行。\n\n## 添加数据库\n\n点击你的应用后面有个图标，可以为应用添加一个数据库，我选择用postgresql9.2，后面再介绍如何进行数据库访问。\n\n# rhc及其一些基本用法\n\nrhc是Openshift的客户端管理程序，利用它可以不必每次都登录到Web控制台上去点鼠标。Ubuntu/Debian可以直接在其官方源里搜索rhc并安装，RHEL/Centos下可以用gem install rhc来，需要系统安装了Ruby和Git。\n\n首次运行rhc需要先进行初始化，```rhc setup```，按照提示输入账户和密码进行初始化后，系统会生成一个token，下一次便不用再输入了，这个token也是有一定有效期的，过期之后还要重新输入密码，以下所有的rhc命令均是。\n\n## 将代码克隆到本地\n\n运行下面的命令可以将刚创建的应用克隆到本地，然后便可以在本地进行编辑。\n\n```\nrhc git-clone mytest\n```\n## 远程登录\n\n我觉得Openshift一个很赞的用法是可以通过ssh远程登录到你的主机平台，有些操作（比如安装Python包，比如看一下远方的环境变量设置，比如看一下远端数据库里的内容（当然Mysql数据库可以通过PhpMyadmin来看）等可以直接登录上去用。\n```\nrhc ssh <appname>\n```\n登录上去后你可以运行env看一下其中的环境变量，其中有几个要用得到的。\n\n* **OPENSHIFT_DATA_DIR**: 是指你的数据目录，指向你的代码目录下的data目录。\n* **OPENSHIFT_REPO_DIR**: 是指你的代码仓库根目录。\n* **OPENSHIFT_POSTGRESQL_DB_URL**: 用sqlalchemy访问postgresql数据库的访问字符串，Mysql的情况没有试过应该也是差不多的，这样需要在你的程序中访问数据库时便用这个环境变量来访问。\n* **OPENSHIFT_PYTHON_PORT**: 对外服务的端口，8080。\n\n\n如果在本地环境中模拟远端的运行，则可以通过设置上述环境变量使其指向本地的路径即可。\n\n## 代码的部署\n\n克隆到本地的代码可以在本地进行修改，用Git进行版本管理，如果需要部署，可以通过git push的形式部署：\n\n```\ngit push origin master\n```\n两点注意的是：\n1. 如果有python依赖包需要安装，则可以在代码的根目录下建一个requirements.txt的文件，里面把依赖的包名称写上，这样每次你push的时候，服务端总会检查一下系统中是否安装了这些包，如果没有安装，则会在部署时用pip进行安装。\n1. 如果想要在远端运行程序（比如初始化数据库）除上直接ssh上去运行外，也可以在.openshift/action_hooks目录下添加一个deploy的可执行脚本，这样在你git push进行部署的时候会自动调用这个脚本。\n\n## scp\n```\nrhc scp mytest upload initial.sql $OPENSHIFT_REPO_DIR/\nrhc scp mytest download ./ $OPENSHIFT_DATA_DIR/test.log\n```\n以上两条命令一是向mytest应用的服务端拷贝文件，第二条是从远程下载文件。\n\n## 创建app\n\n刚才讲的是用Web的方式创建app，你也可以直接用rhc的方式创建：\n```\nrhc app-create mytest python-2.7 postgresql-9.2\n```\n\n即完成刚才Web界面点击的那套东西。\n\n## 查看app的信息\n\n```\nrhc apps\n```\n\n## 查看远程的日志信息\n```\nrhc tail <appname>\n```\n\n还有一些用法可以参见rhc的帮助： \n```\nrhc help\n```\n\n# 开启cron定期运行一些程序\n\n可以在远程部署定期运行的程序，可支持按分钟、小时、天、月、周等不同的周期定期运行程序，比如你可以在上面部署爬虫。\n\n可以运行*rhc cartridge-add cron -a <appname>*为你的程序启用cron。\n\n然后将需要定期运行的脚本放在.openshift/cron/相应的目录下，并把其权限改为可执行的即可。\n\n# 在openshift上部scrapy爬虫的步骤\n\n有这么个资源用来部爬虫我觉得还是挺不错的，当然了，数据量超过1GB的话可能会有问题。\n\n1. 首先在代码目录下建一个requirements.txt的文件，然后写入:\n```\nscrapy\nlxml\n```\n1. 用scrapy写爬虫，然后用git push部署。\n1. 在.openshift/cron/daily下写一个调用scrapy爬虫的脚本，并把其改为可执行文件，即可实现每天定期进行爬虫。\n1. 爬虫的结果如果存储在数据库中直接远程入库即可，如果存储为文件可以通过rhc scp的方式down下来。\n\n# 我自己在使用过程中的一点建议\n\n由于国内直接用rhc访问Openshift有些慢，一点技巧：\n\n* 如果在requirements.txt中写入的依赖包在push的时候安装失败（特别是对于需要编译的情况很容易失败），则可以直接登录上去安装，但最好用nohup的方式安装，这样启动了任务后你的ssh便可以退下，免得ssh断线后安装程序中断。\n```\nnohup pip install -r $OPENSHIFT_REPO_DIR/requirements.txt > /dev/null &\n```\n\n\n\n","source":"_posts/openshift.md","raw":"title: openshift云平台注册使用\ndate: 2016-04-01 08:31:30\ntags:\n---\n【编者按】一直想申请一个免费的托管空间，国内找了一圈sinaapp还算差强人意，但是对于python不以安装C extension的包，而且SAE的一整套流程用起来感觉很不爽，而openshift的平台的工作流更适合一般开发人员的思维模式（我是针对Python，其他语言没有试过没有发言权），鉴于国内关注得还比较少，我把自己注册到开发的经验记录下来，希望对需要的人有所帮助。\n\n# Openshift简介\n\nOpenshift是RedHat公司的一款平台云产品，openshift.com是由RedHat公司维护的一个公有平台云服务平台，提供基础的语言环境、数据库以及其他运维相关的环境。用git实现自动部署，免费用户可以得到1GB的空间，流量无限制。因为RedHat服务器在国外，访问国外的网站速度也会有优势。特别是管理端，可以通过ssh直接登录上去进行调试管理，使用十分方便。语言方面，支持Java、Python、Ruby、Perl、PHP、Node.js等主流的编程语言。\n\n缺点嘛，国外的网站，管理端访问速度确实有点慢，做出来网站的访问速度感觉还可以，当然现在我做的规模还比较小，但对于个人做点事情（比如爬虫）感觉还是可以的。\n\n# Openshift注册及新建应用\n\n## 注册用户\n\n到[Openshift官网](https://www.openshift.com/)点SIGN UP FOR FREE，不过，那个验证码是从google取的，不翻墙的话看不到验证码，不过仅注册的这一次验证码，注册完再登录不需要翻墙便可以正常登录。\n\n![注册界面](openshift_signin.png)\n\n注册可能会发你一封验证邮件，点一下验证邮件里的链接即完成注册，然后便可以用此用户登录使用了。\n\n## 创建新的应用\n\n用你刚注册的用户登录，到 http://www.openshift.com 点击右上角MY ACCOUNT里的WEB CONSOLE菜单登录。登录上去可以看到你的控制台，点击下面的Add Application按钮即可新建一个应用：\n\n![新建应用](openshift_add.png)\n\n点击完后需要你选择应用的类型，比如你可以选择python2.7，当然你也可以选择python3.3，选择完后会让先让你给应用起个名称，名称都会加上你的用户名后缀。\n\n![输入应用相关信息](openshift_appname.png)\n\n其它的选项暂时可以不用改，点击最下面的Create Application按钮，这个应用便是创建完成了。每个免费的用户可以创建3个应用，每个应用1GB的存储空间，包括数据库和语言相关包以及你的所有的程序文件共享这1GB的空间。点完Create Application后可以看到一些提示信息，不管它直接Continue即可。\n\n![Continue](openshift_appnext.png)\n\n服务端会给你的应用建立一个python的virtualenv，你的程序在此virtualenv中运行。\n\n## 添加数据库\n\n点击你的应用后面有个图标，可以为应用添加一个数据库，我选择用postgresql9.2，后面再介绍如何进行数据库访问。\n\n# rhc及其一些基本用法\n\nrhc是Openshift的客户端管理程序，利用它可以不必每次都登录到Web控制台上去点鼠标。Ubuntu/Debian可以直接在其官方源里搜索rhc并安装，RHEL/Centos下可以用gem install rhc来，需要系统安装了Ruby和Git。\n\n首次运行rhc需要先进行初始化，```rhc setup```，按照提示输入账户和密码进行初始化后，系统会生成一个token，下一次便不用再输入了，这个token也是有一定有效期的，过期之后还要重新输入密码，以下所有的rhc命令均是。\n\n## 将代码克隆到本地\n\n运行下面的命令可以将刚创建的应用克隆到本地，然后便可以在本地进行编辑。\n\n```\nrhc git-clone mytest\n```\n## 远程登录\n\n我觉得Openshift一个很赞的用法是可以通过ssh远程登录到你的主机平台，有些操作（比如安装Python包，比如看一下远方的环境变量设置，比如看一下远端数据库里的内容（当然Mysql数据库可以通过PhpMyadmin来看）等可以直接登录上去用。\n```\nrhc ssh <appname>\n```\n登录上去后你可以运行env看一下其中的环境变量，其中有几个要用得到的。\n\n* **OPENSHIFT_DATA_DIR**: 是指你的数据目录，指向你的代码目录下的data目录。\n* **OPENSHIFT_REPO_DIR**: 是指你的代码仓库根目录。\n* **OPENSHIFT_POSTGRESQL_DB_URL**: 用sqlalchemy访问postgresql数据库的访问字符串，Mysql的情况没有试过应该也是差不多的，这样需要在你的程序中访问数据库时便用这个环境变量来访问。\n* **OPENSHIFT_PYTHON_PORT**: 对外服务的端口，8080。\n\n\n如果在本地环境中模拟远端的运行，则可以通过设置上述环境变量使其指向本地的路径即可。\n\n## 代码的部署\n\n克隆到本地的代码可以在本地进行修改，用Git进行版本管理，如果需要部署，可以通过git push的形式部署：\n\n```\ngit push origin master\n```\n两点注意的是：\n1. 如果有python依赖包需要安装，则可以在代码的根目录下建一个requirements.txt的文件，里面把依赖的包名称写上，这样每次你push的时候，服务端总会检查一下系统中是否安装了这些包，如果没有安装，则会在部署时用pip进行安装。\n1. 如果想要在远端运行程序（比如初始化数据库）除上直接ssh上去运行外，也可以在.openshift/action_hooks目录下添加一个deploy的可执行脚本，这样在你git push进行部署的时候会自动调用这个脚本。\n\n## scp\n```\nrhc scp mytest upload initial.sql $OPENSHIFT_REPO_DIR/\nrhc scp mytest download ./ $OPENSHIFT_DATA_DIR/test.log\n```\n以上两条命令一是向mytest应用的服务端拷贝文件，第二条是从远程下载文件。\n\n## 创建app\n\n刚才讲的是用Web的方式创建app，你也可以直接用rhc的方式创建：\n```\nrhc app-create mytest python-2.7 postgresql-9.2\n```\n\n即完成刚才Web界面点击的那套东西。\n\n## 查看app的信息\n\n```\nrhc apps\n```\n\n## 查看远程的日志信息\n```\nrhc tail <appname>\n```\n\n还有一些用法可以参见rhc的帮助： \n```\nrhc help\n```\n\n# 开启cron定期运行一些程序\n\n可以在远程部署定期运行的程序，可支持按分钟、小时、天、月、周等不同的周期定期运行程序，比如你可以在上面部署爬虫。\n\n可以运行*rhc cartridge-add cron -a <appname>*为你的程序启用cron。\n\n然后将需要定期运行的脚本放在.openshift/cron/相应的目录下，并把其权限改为可执行的即可。\n\n# 在openshift上部scrapy爬虫的步骤\n\n有这么个资源用来部爬虫我觉得还是挺不错的，当然了，数据量超过1GB的话可能会有问题。\n\n1. 首先在代码目录下建一个requirements.txt的文件，然后写入:\n```\nscrapy\nlxml\n```\n1. 用scrapy写爬虫，然后用git push部署。\n1. 在.openshift/cron/daily下写一个调用scrapy爬虫的脚本，并把其改为可执行文件，即可实现每天定期进行爬虫。\n1. 爬虫的结果如果存储在数据库中直接远程入库即可，如果存储为文件可以通过rhc scp的方式down下来。\n\n# 我自己在使用过程中的一点建议\n\n由于国内直接用rhc访问Openshift有些慢，一点技巧：\n\n* 如果在requirements.txt中写入的依赖包在push的时候安装失败（特别是对于需要编译的情况很容易失败），则可以直接登录上去安装，但最好用nohup的方式安装，这样启动了任务后你的ssh便可以退下，免得ssh断线后安装程序中断。\n```\nnohup pip install -r $OPENSHIFT_REPO_DIR/requirements.txt > /dev/null &\n```\n\n\n\n","slug":"openshift","published":1,"updated":"2016-04-01T23:06:28.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsj000iaziy2hal27qj"},{"title":"Hello World 演示（Kubernetes）","date":"2016-03-30T09:28:47.000Z","_content":"【译者按】原文出自[kubernetes官方网站](http://kubernetes.io/docs/hellonode/)，通过一个Hello world的node.js应用程序利用k8s进行冗余部署，来讲述k8s的基本操作。译者deerlux@163.com，转载请注明出处。\n\n# 简介\n\n此实验的目标是将一个Hello World的node.js应用在kubernets环境下多副本运行，我们将展示如何在本机上编码，并将其做成Docker容器镜像，然后在[Google Container Engine](https://cloud.google.com/container-engine/)上运行。\n\n下图是本次实验涉及到的各部分之间关系的示意，此图可作为本次实验的全程参考，当本次实验完成时图中所示意的各部分均会涉及到。\n\n![image](http://kubernetes.io/images/hellonode/image_1.png)\n\nKubernetes是一个可运行于不同环境中的开源项目，从笔记本到高可用的多节点集群，从公有云到私有云，从虚拟机到物理机。利用像Google Container Engine（Google的Kubernetes环境）这样的成熟环境，会使你更关注利用Kubernetes本身，而不是把关注点放在部署基础环境上。\n\n\n","source":"_posts/k8sstart.md","raw":"title: Hello World 演示（Kubernetes）\ndate: 2016-03-30 17:28:47\ntags: Linux 云计算\n---\n【译者按】原文出自[kubernetes官方网站](http://kubernetes.io/docs/hellonode/)，通过一个Hello world的node.js应用程序利用k8s进行冗余部署，来讲述k8s的基本操作。译者deerlux@163.com，转载请注明出处。\n\n# 简介\n\n此实验的目标是将一个Hello World的node.js应用在kubernets环境下多副本运行，我们将展示如何在本机上编码，并将其做成Docker容器镜像，然后在[Google Container Engine](https://cloud.google.com/container-engine/)上运行。\n\n下图是本次实验涉及到的各部分之间关系的示意，此图可作为本次实验的全程参考，当本次实验完成时图中所示意的各部分均会涉及到。\n\n![image](http://kubernetes.io/images/hellonode/image_1.png)\n\nKubernetes是一个可运行于不同环境中的开源项目，从笔记本到高可用的多节点集群，从公有云到私有云，从虚拟机到物理机。利用像Google Container Engine（Google的Kubernetes环境）这样的成熟环境，会使你更关注利用Kubernetes本身，而不是把关注点放在部署基础环境上。\n\n\n","slug":"k8sstart","published":1,"updated":"2016-03-30T09:48:30.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsk000jaziytziyyorr"},{"title":"hexo + github 发布静态博客","date":"2014-10-11T15:48:20.000Z","_content":"\n网上的教程很多，我这里只讲一下干货，也是自己的一个备忘。\n\n# 安装node.js\n\n以archlinux下为例，其他的发行版请自行查找相关的软件包。\n\n``` sh\npacman -S nodejs\n```\n\n# 系统中安装hexo\n\n``` sh\nsudo npm install -g hexo\n```\n\n# 初始化blog目录\n\n``` sh\ncd your/blog/dir\nhexo init\n```\n\n# 在目录中安装所依赖的库\n\n``` sh\nnpm install\n```\n\n# 修改 ``_config.yml`` 文件\n\n主要是要修改下面几项\n\n``` yml\ntitle:          # 你的博客名称\nauthor:         # 你的名字\nlanguage: zh_CN # 设置中文\n\nurl: http://deerlux.github.io       # 设置你要发布的地址\nroot: /blog                         # 设置你要发布地址的子目录\n\ntheme: pacman                       # 设置要使用的主题，个人推荐pacman，有很多国内适用的特性。\n\ndeploy:                             # 如果你和我一样用github pages发布，请参照\n  type: github\n  repo: https://github.com/deerlux/blog.git\n  branch: gh-pages\n  message: Updated by hexo          # 这是git提交的消息，你可以改成你需要的。\n\n```\n\n不过一直没有搞定如何设置github的repo为ssh格式的。\n\n# 安装并设置pacman主题\n\n首先到github上下载此主题。\n\n``` sh\ncd your/blog/dir/themes\ngit clone git@github.com/A-limon/pacman\n```\n\n然后进行配置，如果你有新浪微博、多说评论引擎等，可以直接进行配置，改写\nthemes/pacman/_config.yml文件即可。\n\n\n\n","source":"_posts/hexo-blog.md","raw":"title: hexo + github 发布静态博客\ndate: 2014-10-11 23:48:20\ntags: Linux\n---\n\n网上的教程很多，我这里只讲一下干货，也是自己的一个备忘。\n\n# 安装node.js\n\n以archlinux下为例，其他的发行版请自行查找相关的软件包。\n\n``` sh\npacman -S nodejs\n```\n\n# 系统中安装hexo\n\n``` sh\nsudo npm install -g hexo\n```\n\n# 初始化blog目录\n\n``` sh\ncd your/blog/dir\nhexo init\n```\n\n# 在目录中安装所依赖的库\n\n``` sh\nnpm install\n```\n\n# 修改 ``_config.yml`` 文件\n\n主要是要修改下面几项\n\n``` yml\ntitle:          # 你的博客名称\nauthor:         # 你的名字\nlanguage: zh_CN # 设置中文\n\nurl: http://deerlux.github.io       # 设置你要发布的地址\nroot: /blog                         # 设置你要发布地址的子目录\n\ntheme: pacman                       # 设置要使用的主题，个人推荐pacman，有很多国内适用的特性。\n\ndeploy:                             # 如果你和我一样用github pages发布，请参照\n  type: github\n  repo: https://github.com/deerlux/blog.git\n  branch: gh-pages\n  message: Updated by hexo          # 这是git提交的消息，你可以改成你需要的。\n\n```\n\n不过一直没有搞定如何设置github的repo为ssh格式的。\n\n# 安装并设置pacman主题\n\n首先到github上下载此主题。\n\n``` sh\ncd your/blog/dir/themes\ngit clone git@github.com/A-limon/pacman\n```\n\n然后进行配置，如果你有新浪微博、多说评论引擎等，可以直接进行配置，改写\nthemes/pacman/_config.yml文件即可。\n\n\n\n","slug":"hexo-blog","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsm000laziy8p7vbqu0"},{"title":"Hello World","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2015-12-23T11:34:26.916Z","updated":"2015-12-23T11:34:26.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwso000oaziyk4dnaqgn"},{"title":"好妈妈胜过好老师——现代儿童教育启示录","date":"2014-11-15T14:47:54.000Z","_content":"\n一句话的概括\n============\n\n讲的是一种以孩子为核心的家庭教育方式，让人读后能够明白，在对待孩子的所有问题方面，是否充分考虑了孩子的需求和感受，而并非一味的从一个成年人的角度考虑问题。以孩子的兴趣为出发点引导孩子向好的方向发展，才是儿童教育的正道。这本书对每位父母而言都是必读的经典。\n\n感言\n====\n\n老婆推荐我看的一本书《好妈妈胜过好老师——一个教育专家16年的教子手记》，作者尹建莉，作家出版社2009年1月出版。和一个同事一起出差，她推荐我看一本投资方面的书，我却看不下去，拿出这本《好妈妈胜过好老师》来看，回家后给老婆一说起此事，老婆也觉得有些好笑，但看完这本书后确实受益匪浅。\n\n\n其实每个人都希望自己的孩子能够成才，甚至大部分都希望至少要比自己这一辈能够更加出息。因此，希望孩子能够懂礼貌、有教养、多才多艺、学习成绩要名列前矛，这应该是每一个作父母的所期盼的。但是随着生活条件的逐步提高，在子女教育上的物质投入也越来越高，但现代社会上存在的问题儿童却越来越多。\n\n儿童的教育，父母是第一位的，父母可能会很有钱，给孩子上名牌的小学、中学，但是如果家庭的教育或者说父母的教育方式不当，最终还是难以取得较好的效果。\n\n家庭教育是否一切以孩子为核心\n============================\n\n书中讲的几个观点印象特别深，其中最核心的是，在教育孩子的过程中，你是不是以孩子为核心，能否充分考虑孩子的感受。书中举了很多这样的例子，比如她女儿的同学告诉女儿说家里有两柄剑，但这是个秘密，如果你告诉了别人，你的肚子会被刺穿，女儿信以为真，为此事非常烦恼，后来终于鼓足勇气将此事告诉了妈妈。这时候的妈妈并没有像一般人似的嘲笑孩子，而是耐心地给孩子讲道理，充分考虑到了孩子为了保守这个秘密自己承受了多大的痛苦，虽然这些痛苦在大人们看来挺可笑的，但对于孩子而言这却非常重要，如果你去嘲笑孩子以为非常重要的事情，对孩子形成的负面影响将会很大。再有作者比较后悔的一次，带着女儿和另外一个亲戚的小孩去爬山，两个小孩子在非要在地上爬着走，大人硬是把孩子提起来了，后来孩子抱怨说，大人们根本就没有了解孩子，因为他们觉得既然是爬山，为什么不是爬着走，孩子的童趣就在这里，而大人则要考虑孩子的衣服这些锁事，扼杀了孩子的乐趣。\n\n有些孩子调皮，有些孩子表现出来的是听话，但调皮和听话仅仅是表面现象，核心的是是否真正地理解了孩子的所做所为，每一个孩子其实都是挺上进的，他们不喜欢当差生，也并不喜欢总被家长和老师骂，但是每一次父母以为孩子的错误是否从孩子的角度切实地考虑和分析了呢，或者是单纯地以大人的观点去作判断。\n\n每一个孩子都是天使\n==================\n\n每一个孩子都是天使，理应生活在童话的世界里，他们的乐趣其实很简单，但是很多大人却不能站在孩子的角度理解他们。作者夫妇会注意孩子的需求，然后每年圣诞节会有圣诞老人给孩子送礼物，孩子觉得很神奇，甚至在学校里还和老师争辩圣诞老人的有无问题。是啊，童年很是短暂，孩子是天使，理应生活在童话的世界里，等逐渐长大后，便又成了凡人。\n\n阅读的习惯对孩子的基础素质无比重要\n==================================\n\n要尽早培养孩子阅读的习惯，如果孩子能够对阅读感兴趣，会带来很多额外的好处，一是他们可以大大的开拓视野和知识面，二是他们可以为后续的表达能力、写作能力打下很好的基础，三是可以不会沉沦于看电视和玩游戏。其实我自小没有养成很好的阅读习惯，致使现在读的书也偏少。记得一次上中学的时候，自己在家偷偷拿一本武侠小说看，被父亲看到了，狠狠地批评了我一通，后来再也不敢在家里看武侠小说了。高中的时候，仅记得看过一本评书类似的《薜丁山征西》，如果在我中小学时有条件的话，能够多看一些文学水平较高的小说，可能会对我的一生都会有较重要的影响。我无意责备自己的父母，但是在自己教育孩子的过程中却真要避免犯类似的错误。\n\n\n\n","source":"_posts/haomama.md","raw":"title: 好妈妈胜过好老师——现代儿童教育启示录 \ndate: 2014-11-15 22:47:54\ntags: Misc\n---\n\n一句话的概括\n============\n\n讲的是一种以孩子为核心的家庭教育方式，让人读后能够明白，在对待孩子的所有问题方面，是否充分考虑了孩子的需求和感受，而并非一味的从一个成年人的角度考虑问题。以孩子的兴趣为出发点引导孩子向好的方向发展，才是儿童教育的正道。这本书对每位父母而言都是必读的经典。\n\n感言\n====\n\n老婆推荐我看的一本书《好妈妈胜过好老师——一个教育专家16年的教子手记》，作者尹建莉，作家出版社2009年1月出版。和一个同事一起出差，她推荐我看一本投资方面的书，我却看不下去，拿出这本《好妈妈胜过好老师》来看，回家后给老婆一说起此事，老婆也觉得有些好笑，但看完这本书后确实受益匪浅。\n\n\n其实每个人都希望自己的孩子能够成才，甚至大部分都希望至少要比自己这一辈能够更加出息。因此，希望孩子能够懂礼貌、有教养、多才多艺、学习成绩要名列前矛，这应该是每一个作父母的所期盼的。但是随着生活条件的逐步提高，在子女教育上的物质投入也越来越高，但现代社会上存在的问题儿童却越来越多。\n\n儿童的教育，父母是第一位的，父母可能会很有钱，给孩子上名牌的小学、中学，但是如果家庭的教育或者说父母的教育方式不当，最终还是难以取得较好的效果。\n\n家庭教育是否一切以孩子为核心\n============================\n\n书中讲的几个观点印象特别深，其中最核心的是，在教育孩子的过程中，你是不是以孩子为核心，能否充分考虑孩子的感受。书中举了很多这样的例子，比如她女儿的同学告诉女儿说家里有两柄剑，但这是个秘密，如果你告诉了别人，你的肚子会被刺穿，女儿信以为真，为此事非常烦恼，后来终于鼓足勇气将此事告诉了妈妈。这时候的妈妈并没有像一般人似的嘲笑孩子，而是耐心地给孩子讲道理，充分考虑到了孩子为了保守这个秘密自己承受了多大的痛苦，虽然这些痛苦在大人们看来挺可笑的，但对于孩子而言这却非常重要，如果你去嘲笑孩子以为非常重要的事情，对孩子形成的负面影响将会很大。再有作者比较后悔的一次，带着女儿和另外一个亲戚的小孩去爬山，两个小孩子在非要在地上爬着走，大人硬是把孩子提起来了，后来孩子抱怨说，大人们根本就没有了解孩子，因为他们觉得既然是爬山，为什么不是爬着走，孩子的童趣就在这里，而大人则要考虑孩子的衣服这些锁事，扼杀了孩子的乐趣。\n\n有些孩子调皮，有些孩子表现出来的是听话，但调皮和听话仅仅是表面现象，核心的是是否真正地理解了孩子的所做所为，每一个孩子其实都是挺上进的，他们不喜欢当差生，也并不喜欢总被家长和老师骂，但是每一次父母以为孩子的错误是否从孩子的角度切实地考虑和分析了呢，或者是单纯地以大人的观点去作判断。\n\n每一个孩子都是天使\n==================\n\n每一个孩子都是天使，理应生活在童话的世界里，他们的乐趣其实很简单，但是很多大人却不能站在孩子的角度理解他们。作者夫妇会注意孩子的需求，然后每年圣诞节会有圣诞老人给孩子送礼物，孩子觉得很神奇，甚至在学校里还和老师争辩圣诞老人的有无问题。是啊，童年很是短暂，孩子是天使，理应生活在童话的世界里，等逐渐长大后，便又成了凡人。\n\n阅读的习惯对孩子的基础素质无比重要\n==================================\n\n要尽早培养孩子阅读的习惯，如果孩子能够对阅读感兴趣，会带来很多额外的好处，一是他们可以大大的开拓视野和知识面，二是他们可以为后续的表达能力、写作能力打下很好的基础，三是可以不会沉沦于看电视和玩游戏。其实我自小没有养成很好的阅读习惯，致使现在读的书也偏少。记得一次上中学的时候，自己在家偷偷拿一本武侠小说看，被父亲看到了，狠狠地批评了我一通，后来再也不敢在家里看武侠小说了。高中的时候，仅记得看过一本评书类似的《薜丁山征西》，如果在我中小学时有条件的话，能够多看一些文学水平较高的小说，可能会对我的一生都会有较重要的影响。我无意责备自己的父母，但是在自己教育孩子的过程中却真要避免犯类似的错误。\n\n\n\n","slug":"haomama","published":1,"updated":"2015-12-03T11:25:57.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsq000paziya1xc88gh"},{"title":"国产操作系统与数据库——忍不住的吐槽","date":"2014-10-24T13:21:33.000Z","_content":"\n因工作原因，一些系统要上国产化的操作系统、数据库和中间件，和这些国产化系统软件\n的技术人员打交道碰到了一些让我无语的事情。\n\niptables -F \n============\n\n我中间想和别的机子传一些文件，一看系统中的ssh服务已经启动起来了，于是在另外一台\n机器上用ssh登录我的机器，但是明明是能够ping通的 ``ssh my_ip`` 却出现了 ``no\nroute to host MY_IP``错误，我一看就怀疑可能是系统的iptables做了什么手脚，但无奈\n我不会设置iptables。于是叫麒麟操作系统相关的技术人员来，非说我IP地址设置有问题\n，弄了一通他没有弄明白，可能是技术支持的时候也没有碰到过我这样的用户，非要尝试\n一下这种东西，最后信我的话了，直接用 ``iptables -F`` 给我把防火墙的东西清掉了。\n\n我瞬间无语，其实我虽然不懂iptables的配置，但这条命令我还是懂得，就是删除所有的\niptables规则，那你他么还给我系统装什么iptables啊，国产化系统的安全就是这样保障\n的啊？再说了，这也没有解决我问题啊，再重启还是不能，只是暂时可以通了。\n\nchomd -R 777 *\n==================\n\n还有中间件的厂商更是另人蛋疼，号称是通过了公安部XXX认证的中间件厂商，给我的东西\n是个压缩包，直接解压之后就可以用的，但是呢其中bin目录有些可执行的文件没有设置可\n执行权限，我猜人家是在 windows 下打的压缩包，要不然怎会出现这种低级问题，不过人\n家解决的方式也倒是简单，直接到了中间件解压后的根目录，敲了一条另我嘴巴合不拢的\n命令:\n\n``` shell \nchmod -R 777 * \n```\n\n看来人家还是习惯在windows下所有用户对所有文件都可读写的传统，这样的做WEB服务的\n中间件能保证安全？可是我用Linux用点强迫症，ls后看到满屏的绿色，我气就不打一处来\n。\n\nroot用户安装的数据库只能root用\n==============================\n\n数据库产品也是，技术人员演示的是用root用户登录X系统，然后安装，然后运行数据库的\n管理台。我是用普通用户登录，sudo安装，然后用普通用户打开控制台，不行。用sudo在\n命令行里打开控制台可以。但是用普通用户打开控制台就报一个权限的错误，技术人员来\n后坚持说root用户安装的就只能root用户用，如果想用普通用户用的话就用普通用户安装\n。后来来了一个比他更懂行一些的，说可以将安装目录所有文件的属主改成我的登录用户\n。我无语。后来我找到了问题的根源了，每个用户打开控制台的时候都会往安装目录下的\n一个.manager目录里写log，如果普通用户没有对这个目录的写权限则就会报错。数据库系\n统安装的时候将安装目录的权限都设置成了组可写的，因此比较恰当的做法是将允许使用\n数据库的用户的组添加一个这个数据库目录的组即可。\n\n由此我算得出了两个结论：\n\n* 技术支持人员素质太差，基础的Linux安全以及相关的内容知识匮乏。软件设计得不符合\n* Linux的规范，普通用户的log文件按照惯例应该是写在$HOME/.XXX目录下的，为什么要\n  往安装目录下写呢，典型的单用户windows系统的习惯。\n\n我们任重道远啊。\n\n\n\n","source":"_posts/guochan-os.md","raw":"title: 国产操作系统与数据库——忍不住的吐槽\ndate: 2014-10-24 21:21:33 \ntags: Linux\n---\n\n因工作原因，一些系统要上国产化的操作系统、数据库和中间件，和这些国产化系统软件\n的技术人员打交道碰到了一些让我无语的事情。\n\niptables -F \n============\n\n我中间想和别的机子传一些文件，一看系统中的ssh服务已经启动起来了，于是在另外一台\n机器上用ssh登录我的机器，但是明明是能够ping通的 ``ssh my_ip`` 却出现了 ``no\nroute to host MY_IP``错误，我一看就怀疑可能是系统的iptables做了什么手脚，但无奈\n我不会设置iptables。于是叫麒麟操作系统相关的技术人员来，非说我IP地址设置有问题\n，弄了一通他没有弄明白，可能是技术支持的时候也没有碰到过我这样的用户，非要尝试\n一下这种东西，最后信我的话了，直接用 ``iptables -F`` 给我把防火墙的东西清掉了。\n\n我瞬间无语，其实我虽然不懂iptables的配置，但这条命令我还是懂得，就是删除所有的\niptables规则，那你他么还给我系统装什么iptables啊，国产化系统的安全就是这样保障\n的啊？再说了，这也没有解决我问题啊，再重启还是不能，只是暂时可以通了。\n\nchomd -R 777 *\n==================\n\n还有中间件的厂商更是另人蛋疼，号称是通过了公安部XXX认证的中间件厂商，给我的东西\n是个压缩包，直接解压之后就可以用的，但是呢其中bin目录有些可执行的文件没有设置可\n执行权限，我猜人家是在 windows 下打的压缩包，要不然怎会出现这种低级问题，不过人\n家解决的方式也倒是简单，直接到了中间件解压后的根目录，敲了一条另我嘴巴合不拢的\n命令:\n\n``` shell \nchmod -R 777 * \n```\n\n看来人家还是习惯在windows下所有用户对所有文件都可读写的传统，这样的做WEB服务的\n中间件能保证安全？可是我用Linux用点强迫症，ls后看到满屏的绿色，我气就不打一处来\n。\n\nroot用户安装的数据库只能root用\n==============================\n\n数据库产品也是，技术人员演示的是用root用户登录X系统，然后安装，然后运行数据库的\n管理台。我是用普通用户登录，sudo安装，然后用普通用户打开控制台，不行。用sudo在\n命令行里打开控制台可以。但是用普通用户打开控制台就报一个权限的错误，技术人员来\n后坚持说root用户安装的就只能root用户用，如果想用普通用户用的话就用普通用户安装\n。后来来了一个比他更懂行一些的，说可以将安装目录所有文件的属主改成我的登录用户\n。我无语。后来我找到了问题的根源了，每个用户打开控制台的时候都会往安装目录下的\n一个.manager目录里写log，如果普通用户没有对这个目录的写权限则就会报错。数据库系\n统安装的时候将安装目录的权限都设置成了组可写的，因此比较恰当的做法是将允许使用\n数据库的用户的组添加一个这个数据库目录的组即可。\n\n由此我算得出了两个结论：\n\n* 技术支持人员素质太差，基础的Linux安全以及相关的内容知识匮乏。软件设计得不符合\n* Linux的规范，普通用户的log文件按照惯例应该是写在$HOME/.XXX目录下的，为什么要\n  往安装目录下写呢，典型的单用户windows系统的习惯。\n\n我们任重道远啊。\n\n\n\n","slug":"guochan-os","published":1,"updated":"2015-12-03T11:25:57.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwss000saziycbfg4qom"},{"title":"利用gitolite实现自动部署的简易实现方式","date":"2015-04-21T13:22:28.000Z","_content":"\n技术控是不是都象我一样，我想试验在flask框架一些示例程序在nginx+uwsgi的生产环境下的效果，于是想到了用git实现自动部署，于是看到gitolite，于是研究gitolite的服务器配置以及钩子相关的实现方式，看到了网上很多人的回答都不另人满意，其实完全可以有更简单的实现方式。有看官说了，你完全可以写完之后用rsync手动部署啊，但是我的代码库是在自己的一个阿里云服务器上的，我会定期把代码推送到自己的GIT服务器上，我就是不想推送完后再运行一个部署的命令。\n\n下面的配置前提条件是你已经完成了gitolite以及ssh server的一些基本配置，并且用户具有访问gitolite-admin库的权限。如果没有完成这些工作的话，可以参照\n","source":"_posts/gitolite.md","raw":"title: 利用gitolite实现自动部署的简易实现方式\ndate: 2015-04-21 21:22:28\ntags: git 部署\n---\n\n技术控是不是都象我一样，我想试验在flask框架一些示例程序在nginx+uwsgi的生产环境下的效果，于是想到了用git实现自动部署，于是看到gitolite，于是研究gitolite的服务器配置以及钩子相关的实现方式，看到了网上很多人的回答都不另人满意，其实完全可以有更简单的实现方式。有看官说了，你完全可以写完之后用rsync手动部署啊，但是我的代码库是在自己的一个阿里云服务器上的，我会定期把代码推送到自己的GIT服务器上，我就是不想推送完后再运行一个部署的命令。\n\n下面的配置前提条件是你已经完成了gitolite以及ssh server的一些基本配置，并且用户具有访问gitolite-admin库的权限。如果没有完成这些工作的话，可以参照\n","slug":"gitolite","published":1,"updated":"2015-12-03T11:25:57.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsu000uaziyh38ujg9l"},{"title":"利用systemd按需激Docker容器","date":"2015-03-08T11:54:04.000Z","_content":"\n能够延迟启动网络服务应用直到此服务被请求时，是[systemd](http://www.freedesktop.org/wiki/Software/systemd/)的一个特性，它通过一个[socket激活](http://0pointer.de/blog/projects/socket-activation.html)的进程实现。这倒并不是一个新的创意，systemd借用了[OS X](https://www.apple.com/osx/)自2005年[Tiger](http://en.wikipedia.org/wiki/Launchd)版本以来的[launched](http://en.wikipedia.org/wiki/Launchd)的实现思路，再往前追溯，古老的Unix [inetd](http://en.wikipedia.org/wiki/Inetd)在上世纪80年代就实现了这种启动方式的一个简单版本。不管是在脚本驱动还是在事件驱动的启动系统中，Socket激活的方式都具有很多优点，尤其是它能够有效地对应用的启动顺序和服务描述进行解耦合，甚至可以解决一些应用的循环依赖问题。Docker容器（或者其他类型的应用服务例如[systemd's nspawn](http://lwn.net/Articles/572957/)或[LXC](https://linuxcontainers.org/)）大都是一些专用的网络进程，所以将socket激活的方式来启动这些进程会比较有用。\n\n# Socket激活\n\n![Creation of Adam](https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/creation.jpg)\n\nSocket激活是这样工作的：systemd的守护进程代表其他应用监听相关的sockets，只有对应的连接到来的时候才会启动相应的应用服务，然后便将传入的连接交给新启动的应用服务，此应用负责对这个连接进行响应。\n\n但是这里的限制之一是，它需要被激活的应用知晓它是可以被socket激活的，并且对现成的socket的处理——尽管[简单](http://0pointer.de/blog/projects/socket-activation.html)——并不同于从头创建一个监听socket。因此，很多广泛应用的软件（如[ngix](http://trac.nginx.org/nginx/ticket/237)）并不支持这种方式，软件容器化的趋势添加了另外需要激活的层则进一步加剧了这种限制条件的影响。但是可以通过将其交给容器的方式针对任意容器化的应用解决此问题。\n\n# Socket激活和Docker\n\n如果你Google \"docker container systemd socket activation\" 你会发现很少的相关的讨论，大部分的结论都是除非Docker给出了这方面的支持否则不可能，但Dcoker支持虽然是最优的解决方式但并不是全部。Sytemd的开发者已经知识在任意情况下都可以激活可能解决起来颇费周折，因此在[209](http://article.gmane.org/gmane.comp.sysutils.systemd.devel/16993)版本时引入了[systemd-socket-proxyd](http://www.freedesktop.org/software/systemd/man/systemd-socket-proxyd.html)——一个小的TCP和UNIX域socket代理。这个东西才是真正的理解了激活的含义，它可以坐在网络和我们的容器之间，透明地在二者之间转发包，因此我们可以通过少许的[units](http://www.freedesktop.org/software/systemd/man/systemd.unit.html)（systemd的配置系统）为Docker容器创建一个socket激活的框架。\n\n**警示**：当前的Ubuntu发行版本systemd是208版本，还没有systemd-socket-proxyd，要想试验下述例子必须systemd 209版本或更高，Debian的Jessie pre-release版本可以，基于RedHat的最新的发行版如Fedora应该也可以。\n\n# 如何工作的\n\n通常，我们用一个演示来简化说明问题：\n\n![system activation animation](https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/systemd-docker.gif)\n\n我们看一下到底发生了什么事情：\n\n1. 我们创建了一个socket监听相应的端口，它是由代理/容器依事件驱动合并进行服务的；\n1. 当第一个连接来的时候，systemd激活了代理服务用来处理这个socket；\n1. 还有一个由容器提供的被动式服务——代理依赖于此服务，代理启动之前首先要启动这个容器；\n1. 代理负责在网络和容器之前传送所有的流量。\n\n虽然需要一些技巧，但从概念上讲这是相当简单的，那么我们以systemd和一个ngix的容器来练习一下如何实现。\n\n# 使其运行\n## 创建容器\n\n首先我们要创建目标容器，这里我们利用[官方镜像](https://registry.hub.docker.com/_/nginx/)创建一个空的ngix容器。\n\n``` shell\ndocker create --name ngix8080 -p 8080:80 ngix\n```\n\n这与你执行任何容器均类似，不过注意我们用的是*create*而不是*run*，因为我们并不想这个容器马上启动，我们还对此窗口进行了命名以便于后面启动它。\n\n这里唯一一点技巧是你需要将此容器绑定到另外一个端口（这里我们用的是8080代替的80），这是因为这个端口（80）\n\n现在我们有了一个容器，这样便可以创建激活管道，首先我们需要初始的监听socket也就是[socket unit](http://www.freedesktop.org/software/systemd/man/systemd.socket.html)，这个socket的行为是高度可配置的，但是我们的例子中非常简单。\n\n``` ini\n[Socket]\nListenStream=80\n[Install]\nWantedBy=socktes.target\n```\n\n*[Socket]*节表示一个简单的80端口的和TCP监听，*[Install]*节告诉systemd什么时候启动这个socket，在此例中它与系统配置的其他socket一起启动。我们将此unit写入名为*/etc/systedm/system/nginx-proxy.socket*的文件中，这只是启动后需要激活的链条中的一部分，我们还需要告诉systemd启动它：\n\n``` shell\nsystemctl enable nginx-proxy.socket\nsystemctl start nginx-proxy.socket\n```\n\n## 代理服务\n\n当systemd接收到一个到此socket的连接时它化自动查找一个相同名称的[服务](http://www.freedesktop.org/software/systemd/man/systemd.service.html)并启动它。我们需要创建服务文件*/etc/systemd/systedm/nginx-proxy.service*：\n\n``` ini\n[Unit]\nRequires=nginx-docker.service\nAfter=nginx-docker.service\n\n[Service]\nExecStart=/lib/systemd/systemd-socket-proxyd 127.0.0.1:8080\n```\n\n*[Unit]*节描述了此服务的依赖，此例中我们告诉systemd在代理启动之前必须先将实际的容器（下面我们将要配置此服务）启动。*[Section]*节为启动代理进程的响应，当前此节还可以配置[大量的内容](http://www.freedesktop.org/software/systemd/man/systemd.service.html)，比如进程启动失败的处理，但是对于我们的应用一个简单的启动就OK了。注意我们将socket转发到了8080端口，这是我们的容器将要监听的端口；我们也并没有告诉systemd监听80端口，它只是用了systemd处理的socket。还要注意到上述配置文件中没有*[Install]*节，此服务并非是缺省启动，而是由socket激活它。\n\n## 启动Docker容器\n\n正如前面提到了，代理利用*Requre/After*机制触发了容器的启动，此容器的启动文件在*/etc/systemd/system/nginx-docker.service*，它看起来是这样的：\n\n``` ini\n[Unit]\nDescription=nginx container\n\n[Service]\nExecStart=/usr/bin/docker start -a nginx8080\nExecStartPost=/bin/sleep 1\n\nExecStop=/usr/bin/docker stop nginx8080\n```\n\n与上述代理服务的基本概念相同，*ExecStart*行告诉systemd如何启动这个容器，systemd喜欢让进程不要在后台运行，所以我们添加了*-a*参数，这使得此容器在前台运行并且将nginx的运行日志转发到[journald](http://0pointer.de/blog/projects/journalctl.html)logger中，*ExecStop*告诉systemd当运行*systemctl stop ngix-docker*时如何停止容器。\n\n这里我们还利用*ExecStartPost*行耍了一个小聪明，这是systemd在主进程启动后立马要运行的进程，此例中我们在继续往下走之前让其sleep了1秒钟。这是必要的，因为尽管docker启动容器非常快，但是容器中的进程的启动可能需要稍微长一点的时间完成初始化，systemd也非常快，所以有可能代理在nginx准备好接收之前就开始转发了，所以我们添加了一点延迟，给Dcoker/nginx一个空闲启动，这有点耍赖但是很有效（但是看[下面](#容器服务改进)）\n\n# 一切就绪\n\n现在你可以：当systemd启动的时候开启一个socket，当第一个连接到达时，级联的依赖关系会使nginx Docker通过代理对此连接进行响应。Easy。\n\n# 容器服务改进\n\n任何想要优化系统启动时间的人都恨死了在代码或配置文件中随意添加诸如*sleep*的语句，他们要么是因系统很快而不需要此延迟，要么是得到了很多难以定位的随机错误。上述*ExecStartPost*中的*sleep*语句也同样使我神经过敏，所以我也想把它删了。其实我们真正想做的是确认端口的监听已经启动了，但是通过了一种sleep的方式。我们可以通过一种循环检测端口是否已经正常启动的方式来实现，我用[netcat](http://en.wikipedia.org/wiki/Netcat)写了一个wrapper的脚本。\n\n``` shell\n#!/bin/bash\n\nhost=$1\nport=$2\ntries=600\n\nfor i in `seq $tries`; do\n    if /bin/nc -z $host $port > /dev/null ; then\n        # Ready\n        exit 0\n    fi\n\n    /bin/sleep 0.1\ndone\n\n# FAIL\nexit -1\n```\n\n这个脚本需要一个host和port的参数，检查一下是否有响应，每秒钟检查10次，如果1分钟之内还没有响应就返回失败。我们将此脚本安装到*/usr/local/bin/waitport*（设置其为可运行），现在我们的*nginx-docker.service*文件改为这样：\n\n``` ini\n[Unit]\nDescription=nginx container\n\n[Service]\nExecStart=/usr/bin/docker start -a nginx8080\nExecStartPost=/usr/local/bin/waitport 127.0.0.1 8080\n\nExecStop=/usr/bin/docker stop nginx8080\n```\n\n也就是说，waitport脚本可以根据你的系统应用灵活调整，如果你的容器启动速度很快的话通常都会立即返回。\n\n\n","source":"_posts/docker-systemd-socket-activation.md","raw":"title: 利用systemd按需激Docker容器\ndate: 2015-03-08 19:54:04\ntags:\n---\n\n能够延迟启动网络服务应用直到此服务被请求时，是[systemd](http://www.freedesktop.org/wiki/Software/systemd/)的一个特性，它通过一个[socket激活](http://0pointer.de/blog/projects/socket-activation.html)的进程实现。这倒并不是一个新的创意，systemd借用了[OS X](https://www.apple.com/osx/)自2005年[Tiger](http://en.wikipedia.org/wiki/Launchd)版本以来的[launched](http://en.wikipedia.org/wiki/Launchd)的实现思路，再往前追溯，古老的Unix [inetd](http://en.wikipedia.org/wiki/Inetd)在上世纪80年代就实现了这种启动方式的一个简单版本。不管是在脚本驱动还是在事件驱动的启动系统中，Socket激活的方式都具有很多优点，尤其是它能够有效地对应用的启动顺序和服务描述进行解耦合，甚至可以解决一些应用的循环依赖问题。Docker容器（或者其他类型的应用服务例如[systemd's nspawn](http://lwn.net/Articles/572957/)或[LXC](https://linuxcontainers.org/)）大都是一些专用的网络进程，所以将socket激活的方式来启动这些进程会比较有用。\n\n# Socket激活\n\n![Creation of Adam](https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/creation.jpg)\n\nSocket激活是这样工作的：systemd的守护进程代表其他应用监听相关的sockets，只有对应的连接到来的时候才会启动相应的应用服务，然后便将传入的连接交给新启动的应用服务，此应用负责对这个连接进行响应。\n\n但是这里的限制之一是，它需要被激活的应用知晓它是可以被socket激活的，并且对现成的socket的处理——尽管[简单](http://0pointer.de/blog/projects/socket-activation.html)——并不同于从头创建一个监听socket。因此，很多广泛应用的软件（如[ngix](http://trac.nginx.org/nginx/ticket/237)）并不支持这种方式，软件容器化的趋势添加了另外需要激活的层则进一步加剧了这种限制条件的影响。但是可以通过将其交给容器的方式针对任意容器化的应用解决此问题。\n\n# Socket激活和Docker\n\n如果你Google \"docker container systemd socket activation\" 你会发现很少的相关的讨论，大部分的结论都是除非Docker给出了这方面的支持否则不可能，但Dcoker支持虽然是最优的解决方式但并不是全部。Sytemd的开发者已经知识在任意情况下都可以激活可能解决起来颇费周折，因此在[209](http://article.gmane.org/gmane.comp.sysutils.systemd.devel/16993)版本时引入了[systemd-socket-proxyd](http://www.freedesktop.org/software/systemd/man/systemd-socket-proxyd.html)——一个小的TCP和UNIX域socket代理。这个东西才是真正的理解了激活的含义，它可以坐在网络和我们的容器之间，透明地在二者之间转发包，因此我们可以通过少许的[units](http://www.freedesktop.org/software/systemd/man/systemd.unit.html)（systemd的配置系统）为Docker容器创建一个socket激活的框架。\n\n**警示**：当前的Ubuntu发行版本systemd是208版本，还没有systemd-socket-proxyd，要想试验下述例子必须systemd 209版本或更高，Debian的Jessie pre-release版本可以，基于RedHat的最新的发行版如Fedora应该也可以。\n\n# 如何工作的\n\n通常，我们用一个演示来简化说明问题：\n\n![system activation animation](https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/systemd-docker.gif)\n\n我们看一下到底发生了什么事情：\n\n1. 我们创建了一个socket监听相应的端口，它是由代理/容器依事件驱动合并进行服务的；\n1. 当第一个连接来的时候，systemd激活了代理服务用来处理这个socket；\n1. 还有一个由容器提供的被动式服务——代理依赖于此服务，代理启动之前首先要启动这个容器；\n1. 代理负责在网络和容器之前传送所有的流量。\n\n虽然需要一些技巧，但从概念上讲这是相当简单的，那么我们以systemd和一个ngix的容器来练习一下如何实现。\n\n# 使其运行\n## 创建容器\n\n首先我们要创建目标容器，这里我们利用[官方镜像](https://registry.hub.docker.com/_/nginx/)创建一个空的ngix容器。\n\n``` shell\ndocker create --name ngix8080 -p 8080:80 ngix\n```\n\n这与你执行任何容器均类似，不过注意我们用的是*create*而不是*run*，因为我们并不想这个容器马上启动，我们还对此窗口进行了命名以便于后面启动它。\n\n这里唯一一点技巧是你需要将此容器绑定到另外一个端口（这里我们用的是8080代替的80），这是因为这个端口（80）\n\n现在我们有了一个容器，这样便可以创建激活管道，首先我们需要初始的监听socket也就是[socket unit](http://www.freedesktop.org/software/systemd/man/systemd.socket.html)，这个socket的行为是高度可配置的，但是我们的例子中非常简单。\n\n``` ini\n[Socket]\nListenStream=80\n[Install]\nWantedBy=socktes.target\n```\n\n*[Socket]*节表示一个简单的80端口的和TCP监听，*[Install]*节告诉systemd什么时候启动这个socket，在此例中它与系统配置的其他socket一起启动。我们将此unit写入名为*/etc/systedm/system/nginx-proxy.socket*的文件中，这只是启动后需要激活的链条中的一部分，我们还需要告诉systemd启动它：\n\n``` shell\nsystemctl enable nginx-proxy.socket\nsystemctl start nginx-proxy.socket\n```\n\n## 代理服务\n\n当systemd接收到一个到此socket的连接时它化自动查找一个相同名称的[服务](http://www.freedesktop.org/software/systemd/man/systemd.service.html)并启动它。我们需要创建服务文件*/etc/systemd/systedm/nginx-proxy.service*：\n\n``` ini\n[Unit]\nRequires=nginx-docker.service\nAfter=nginx-docker.service\n\n[Service]\nExecStart=/lib/systemd/systemd-socket-proxyd 127.0.0.1:8080\n```\n\n*[Unit]*节描述了此服务的依赖，此例中我们告诉systemd在代理启动之前必须先将实际的容器（下面我们将要配置此服务）启动。*[Section]*节为启动代理进程的响应，当前此节还可以配置[大量的内容](http://www.freedesktop.org/software/systemd/man/systemd.service.html)，比如进程启动失败的处理，但是对于我们的应用一个简单的启动就OK了。注意我们将socket转发到了8080端口，这是我们的容器将要监听的端口；我们也并没有告诉systemd监听80端口，它只是用了systemd处理的socket。还要注意到上述配置文件中没有*[Install]*节，此服务并非是缺省启动，而是由socket激活它。\n\n## 启动Docker容器\n\n正如前面提到了，代理利用*Requre/After*机制触发了容器的启动，此容器的启动文件在*/etc/systemd/system/nginx-docker.service*，它看起来是这样的：\n\n``` ini\n[Unit]\nDescription=nginx container\n\n[Service]\nExecStart=/usr/bin/docker start -a nginx8080\nExecStartPost=/bin/sleep 1\n\nExecStop=/usr/bin/docker stop nginx8080\n```\n\n与上述代理服务的基本概念相同，*ExecStart*行告诉systemd如何启动这个容器，systemd喜欢让进程不要在后台运行，所以我们添加了*-a*参数，这使得此容器在前台运行并且将nginx的运行日志转发到[journald](http://0pointer.de/blog/projects/journalctl.html)logger中，*ExecStop*告诉systemd当运行*systemctl stop ngix-docker*时如何停止容器。\n\n这里我们还利用*ExecStartPost*行耍了一个小聪明，这是systemd在主进程启动后立马要运行的进程，此例中我们在继续往下走之前让其sleep了1秒钟。这是必要的，因为尽管docker启动容器非常快，但是容器中的进程的启动可能需要稍微长一点的时间完成初始化，systemd也非常快，所以有可能代理在nginx准备好接收之前就开始转发了，所以我们添加了一点延迟，给Dcoker/nginx一个空闲启动，这有点耍赖但是很有效（但是看[下面](#容器服务改进)）\n\n# 一切就绪\n\n现在你可以：当systemd启动的时候开启一个socket，当第一个连接到达时，级联的依赖关系会使nginx Docker通过代理对此连接进行响应。Easy。\n\n# 容器服务改进\n\n任何想要优化系统启动时间的人都恨死了在代码或配置文件中随意添加诸如*sleep*的语句，他们要么是因系统很快而不需要此延迟，要么是得到了很多难以定位的随机错误。上述*ExecStartPost*中的*sleep*语句也同样使我神经过敏，所以我也想把它删了。其实我们真正想做的是确认端口的监听已经启动了，但是通过了一种sleep的方式。我们可以通过一种循环检测端口是否已经正常启动的方式来实现，我用[netcat](http://en.wikipedia.org/wiki/Netcat)写了一个wrapper的脚本。\n\n``` shell\n#!/bin/bash\n\nhost=$1\nport=$2\ntries=600\n\nfor i in `seq $tries`; do\n    if /bin/nc -z $host $port > /dev/null ; then\n        # Ready\n        exit 0\n    fi\n\n    /bin/sleep 0.1\ndone\n\n# FAIL\nexit -1\n```\n\n这个脚本需要一个host和port的参数，检查一下是否有响应，每秒钟检查10次，如果1分钟之内还没有响应就返回失败。我们将此脚本安装到*/usr/local/bin/waitport*（设置其为可运行），现在我们的*nginx-docker.service*文件改为这样：\n\n``` ini\n[Unit]\nDescription=nginx container\n\n[Service]\nExecStart=/usr/bin/docker start -a nginx8080\nExecStartPost=/usr/local/bin/waitport 127.0.0.1 8080\n\nExecStop=/usr/bin/docker stop nginx8080\n```\n\n也就是说，waitport脚本可以根据你的系统应用灵活调整，如果你的容器启动速度很快的话通常都会立即返回。\n\n\n","slug":"docker-systemd-socket-activation","published":1,"updated":"2015-12-03T11:25:57.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsw000xaziyd3t2lo2z"},{"title":"Archlinux下安装nginx、Fastcgi","date":"2015-03-17T12:51:19.000Z","_content":"\n\n以前一直用apache作为web服务，但是最近只能在一个上网本上编些程序，配置较差，所以想换nginx作为web服务。Archlinux的WIKI其实是很不错的文档，照着里面的说明很多问题都可以解决，但没想到在配置nginx和fastcgi的时候碰到了一些问题，后来才发现WIKI中有个配置文件错了。本文的配置方法基本与官文WIKI相同，只是完成一个基本的配置，能够使nginx下能够正常调用fastcgi运行相关的PHP程序，但是对于相关的配置文件及一些机理性的东西进行总结。\n\n# nginx-fastcgi的工作机制\n\n\n","source":"_posts/archlinux-nginx-fastcgi.md","raw":"title: Archlinux下安装nginx、Fastcgi\ndate: 2015-03-17 20:51:19\ntags: 系统运维\n---\n\n\n以前一直用apache作为web服务，但是最近只能在一个上网本上编些程序，配置较差，所以想换nginx作为web服务。Archlinux的WIKI其实是很不错的文档，照着里面的说明很多问题都可以解决，但没想到在配置nginx和fastcgi的时候碰到了一些问题，后来才发现WIKI中有个配置文件错了。本文的配置方法基本与官文WIKI相同，只是完成一个基本的配置，能够使nginx下能够正常调用fastcgi运行相关的PHP程序，但是对于相关的配置文件及一些机理性的东西进行总结。\n\n# nginx-fastcgi的工作机制\n\n\n","slug":"archlinux-nginx-fastcgi","published":1,"updated":"2015-12-03T11:25:57.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsx000yaziyq1aw40v8"},{"title":"anacron异步定时任务调度","date":"2016-04-07T14:40:17.000Z","_content":"\n# Anacron是什么\n\n众所周知，***cron***是*nix系统下的一种定时任务调度器，可以实现任意用户周期性运行特定任务的需要，常用在自动维护和管理中。而***anacron***是一种异步的定时任务调度器，大家都知道cron是Linux系统下的定时任务调度器，可以实现异步的任务调度。对于24小时开机运行的服务器可能用不到这种东西，但是非24小时开机，又想定时运行任务的机器还是十分有用的，可以实现异步的调用。\n\n目前很多发行牌中的cron是由cronie实现的，而cronie中集成了anacron。\n\n# Anacron配置\n\nanacron的配置与cron类似，也是要首先配置一个叫anacrontab的文件，其文件格式说明一般在manual里有```man anacrontab```。\n\n* 可以定义启动程序的环境变量，其中\n  * START_HOURS_RANGE=17-23：表示程序在17时至23时之间会启动\n  * RANDOM_DELAY=5：表示定时触发后随机延迟5分钟以内的时间再启动应用（主要是防止一开机多任务同时启动造成负载过重）。\n* 任务定义的格式：\n  * 1   5   crawl   $HOME/bin/mycrawl ：第一列表示格几个小时启动一次，第二列表示触发后延迟的分钟数，最终的延迟时间是5+RANDOM_DELAY，第三列是任务名称，第四列是要运行的命令及相关的参数。\n\n一个完整的配置文件如下：\n```\nSHELL=/bin/sh\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nRANDOM_DELAY=10\nSTART_HOURS_RANGE=17-23\n1   5   crawl   $HOME/bin/mycrawl\n```\n\n将上述文件存储为$HOME/anacrontab，然后运行：\n```\n$ anacrontab -t anacronta -S ~/.anacron\n```\n\n运行完后过几分钟，crawl任务便会启动。其中-t参数是指定anacrontab文件，-S参数是指定anacron的缓存路径，这个路径必需是已经建立好的一个目录。\n\n# Anacron的实现原理以及使用方式\n\nAnacron是基于cron的，并没有要代替cron，一般的用法是由cron在周期性调用anacron，利用anacron定义的规则来启动相关的应用。比如系统中在/etc/cron.hourly下一般会有一个```0anacron```的文件，此文件用于启动```/etc/anacrontab```中定义的任务。如果要实现异步的周期性任务，还需要再定义相应的crontab。\n\n运行```crontab -e```，并写下按小时调用的规则：\n\n```\n15 * * * * anacrontab -t $HOME/anacrontab -S $HOME/.anacron\n```\n\n每次调用anacrontab时，会监测一下$HOME/.anacron目录下crawl（任务名称）文件是否存在并且其内容是否为当前今天的日期，如果是今天的日期，则表明今天已经调用过了，如果不是今天的日期，则启动$HOME/bin/mycrawl程序，再把内容改为今天的日期。以这种方式实现了即使关机的情况下也会定期运行相关的任务。\n\n\n\n","source":"_posts/anacron.md","raw":"title: anacron异步定时任务调度\ndate: 2016-04-07 22:40:17\ntags:\n---\n\n# Anacron是什么\n\n众所周知，***cron***是*nix系统下的一种定时任务调度器，可以实现任意用户周期性运行特定任务的需要，常用在自动维护和管理中。而***anacron***是一种异步的定时任务调度器，大家都知道cron是Linux系统下的定时任务调度器，可以实现异步的任务调度。对于24小时开机运行的服务器可能用不到这种东西，但是非24小时开机，又想定时运行任务的机器还是十分有用的，可以实现异步的调用。\n\n目前很多发行牌中的cron是由cronie实现的，而cronie中集成了anacron。\n\n# Anacron配置\n\nanacron的配置与cron类似，也是要首先配置一个叫anacrontab的文件，其文件格式说明一般在manual里有```man anacrontab```。\n\n* 可以定义启动程序的环境变量，其中\n  * START_HOURS_RANGE=17-23：表示程序在17时至23时之间会启动\n  * RANDOM_DELAY=5：表示定时触发后随机延迟5分钟以内的时间再启动应用（主要是防止一开机多任务同时启动造成负载过重）。\n* 任务定义的格式：\n  * 1   5   crawl   $HOME/bin/mycrawl ：第一列表示格几个小时启动一次，第二列表示触发后延迟的分钟数，最终的延迟时间是5+RANDOM_DELAY，第三列是任务名称，第四列是要运行的命令及相关的参数。\n\n一个完整的配置文件如下：\n```\nSHELL=/bin/sh\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nRANDOM_DELAY=10\nSTART_HOURS_RANGE=17-23\n1   5   crawl   $HOME/bin/mycrawl\n```\n\n将上述文件存储为$HOME/anacrontab，然后运行：\n```\n$ anacrontab -t anacronta -S ~/.anacron\n```\n\n运行完后过几分钟，crawl任务便会启动。其中-t参数是指定anacrontab文件，-S参数是指定anacron的缓存路径，这个路径必需是已经建立好的一个目录。\n\n# Anacron的实现原理以及使用方式\n\nAnacron是基于cron的，并没有要代替cron，一般的用法是由cron在周期性调用anacron，利用anacron定义的规则来启动相关的应用。比如系统中在/etc/cron.hourly下一般会有一个```0anacron```的文件，此文件用于启动```/etc/anacrontab```中定义的任务。如果要实现异步的周期性任务，还需要再定义相应的crontab。\n\n运行```crontab -e```，并写下按小时调用的规则：\n\n```\n15 * * * * anacrontab -t $HOME/anacrontab -S $HOME/.anacron\n```\n\n每次调用anacrontab时，会监测一下$HOME/.anacron目录下crawl（任务名称）文件是否存在并且其内容是否为当前今天的日期，如果是今天的日期，则表明今天已经调用过了，如果不是今天的日期，则启动$HOME/bin/mycrawl程序，再把内容改为今天的日期。以这种方式实现了即使关机的情况下也会定期运行相关的任务。\n\n\n\n","slug":"anacron","published":1,"updated":"2016-04-07T15:26:33.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjadslwsz0011aziyu49971o9"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjadslwr00000aziyaz2sqky2","tag_id":"cjadslwr50001aziyco7vwr9h","_id":"cjadslwr60002aziyriioru5g"},{"post_id":"cjadslws90004aziye68fc19a","tag_id":"cjadslws90005aziy3a8qzl5f","_id":"cjadslwsa0006aziyk3a0fd96"},{"post_id":"cjadslwsb0007aziytu921oil","tag_id":"cjadslws90005aziy3a8qzl5f","_id":"cjadslwsc0008aziysxs8cv9h"},{"post_id":"cjadslwsd0009aziy9ebzksdh","tag_id":"cjadslwsd000aaziyrhjb3chx","_id":"cjadslwse000baziyy71c1efx"},{"post_id":"cjadslwsf000caziys356ebzg","tag_id":"cjadslwsf000daziyqdb9f26p","_id":"cjadslwsg000eaziyfeib6zz4"},{"post_id":"cjadslwsh000faziyeuk3zg1n","tag_id":"cjadslwsh000gaziybym5ewcw","_id":"cjadslwsh000haziycfdwe7if"},{"post_id":"cjadslwsk000jaziytziyyorr","tag_id":"cjadslwsd000aaziyrhjb3chx","_id":"cjadslwsl000kaziy73b5cp94"},{"post_id":"cjadslwsm000laziy8p7vbqu0","tag_id":"cjadslwsn000maziywk14tohu","_id":"cjadslwsn000naziycxt34w9u"},{"post_id":"cjadslwsq000paziya1xc88gh","tag_id":"cjadslwsr000qaziyiv8z7rrj","_id":"cjadslwsr000raziy5hix4lp6"},{"post_id":"cjadslwss000saziycbfg4qom","tag_id":"cjadslwsn000maziywk14tohu","_id":"cjadslwst000taziy2lixswrc"},{"post_id":"cjadslwsu000uaziyh38ujg9l","tag_id":"cjadslwsu000vaziyh46drejh","_id":"cjadslwsv000waziyhff4m36m"},{"post_id":"cjadslwsx000yaziyq1aw40v8","tag_id":"cjadslwsy000zaziy6unk4jat","_id":"cjadslwsy0010aziyplhf2m64"}],"Tag":[{"name":"python linux","_id":"cjadslwr50001aziyco7vwr9h"},{"name":"读书笔记","_id":"cjadslws90005aziy3a8qzl5f"},{"name":"Linux 云计算","_id":"cjadslwsd000aaziyrhjb3chx"},{"name":"虚拟化","_id":"cjadslwsf000daziyqdb9f26p"},{"name":"Python","_id":"cjadslwsh000gaziybym5ewcw"},{"name":"Linux","_id":"cjadslwsn000maziywk14tohu"},{"name":"Misc","_id":"cjadslwsr000qaziyiv8z7rrj"},{"name":"git 部署","_id":"cjadslwsu000vaziyh46drejh"},{"name":"系统运维","_id":"cjadslwsy000zaziy6unk4jat"}]}}