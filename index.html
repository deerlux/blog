<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://deerlux.github.io/blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://deerlux.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gitolite" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/21/gitolite/" class="article-date">
  <time datetime="2015-04-21T13:22:28.000Z" itemprop="datePublished">2015-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/21/gitolite/">利用gitolite实现自动部署的简易实现方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>技术控是不是都象我一样，我想试验在flask框架一些示例程序在nginx+uwsgi的生产环境下的效果，于是想到了用git实现自动部署，于是看到gitolite，于是研究gitolite的服务器配置以及钩子相关的实现方式，看到了网上很多人的回答都不另人满意，其实完全可以有更简单的实现方式。有看官说了，你完全可以写完之后用rsync手动部署啊，但是我的代码库是在自己的一个阿里云服务器上的，我会定期把代码推送到自己的GIT服务器上，我就是不想推送完后再运行一个部署的命令。</p>
<p>下面的配置前提条件是你已经完成了gitolite以及ssh server的一些基本配置，并且用户具有访问gitolite-admin库的权限。如果没有完成这些工作的话，可以参照</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2015/04/21/gitolite/" data-id="ck3ldyt8t00039eimvdr6zqhj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git-部署/">git 部署</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-archlinux-nginx-fastcgi" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/17/archlinux-nginx-fastcgi/" class="article-date">
  <time datetime="2015-03-17T12:51:19.000Z" itemprop="datePublished">2015-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/17/archlinux-nginx-fastcgi/">Archlinux下安装nginx、Fastcgi</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以前一直用apache作为web服务，但是最近只能在一个上网本上编些程序，配置较差，所以想换nginx作为web服务。Archlinux的WIKI其实是很不错的文档，照着里面的说明很多问题都可以解决，但没想到在配置nginx和fastcgi的时候碰到了一些问题，后来才发现WIKI中有个配置文件错了。本文的配置方法基本与官文WIKI相同，只是完成一个基本的配置，能够使nginx下能够正常调用fastcgi运行相关的PHP程序，但是对于相关的配置文件及一些机理性的东西进行总结。</p>
<h1 id="nginx-fastcgi的工作机制"><a href="#nginx-fastcgi的工作机制" class="headerlink" title="nginx-fastcgi的工作机制"></a>nginx-fastcgi的工作机制</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2015/03/17/archlinux-nginx-fastcgi/" data-id="ck3ldyt8l00009eimts6l0h63" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统运维/">系统运维</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker-systemd-socket-activation" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/08/docker-systemd-socket-activation/" class="article-date">
  <time datetime="2015-03-08T11:54:04.000Z" itemprop="datePublished">2015-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/08/docker-systemd-socket-activation/">利用systemd按需激Docker容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>能够延迟启动网络服务应用直到此服务被请求时，是<a href="http://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a>的一个特性，它通过一个<a href="http://0pointer.de/blog/projects/socket-activation.html" target="_blank" rel="noopener">socket激活</a>的进程实现。这倒并不是一个新的创意，systemd借用了<a href="https://www.apple.com/osx/" target="_blank" rel="noopener">OS X</a>自2005年<a href="http://en.wikipedia.org/wiki/Launchd" target="_blank" rel="noopener">Tiger</a>版本以来的<a href="http://en.wikipedia.org/wiki/Launchd" target="_blank" rel="noopener">launched</a>的实现思路，再往前追溯，古老的Unix <a href="http://en.wikipedia.org/wiki/Inetd" target="_blank" rel="noopener">inetd</a>在上世纪80年代就实现了这种启动方式的一个简单版本。不管是在脚本驱动还是在事件驱动的启动系统中，Socket激活的方式都具有很多优点，尤其是它能够有效地对应用的启动顺序和服务描述进行解耦合，甚至可以解决一些应用的循环依赖问题。Docker容器（或者其他类型的应用服务例如<a href="http://lwn.net/Articles/572957/" target="_blank" rel="noopener">systemd’s nspawn</a>或<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXC</a>）大都是一些专用的网络进程，所以将socket激活的方式来启动这些进程会比较有用。</p>
<h1 id="Socket激活"><a href="#Socket激活" class="headerlink" title="Socket激活"></a>Socket激活</h1><p><img src="https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/creation.jpg" alt="Creation of Adam"></p>
<p>Socket激活是这样工作的：systemd的守护进程代表其他应用监听相关的sockets，只有对应的连接到来的时候才会启动相应的应用服务，然后便将传入的连接交给新启动的应用服务，此应用负责对这个连接进行响应。</p>
<p>但是这里的限制之一是，它需要被激活的应用知晓它是可以被socket激活的，并且对现成的socket的处理——尽管<a href="http://0pointer.de/blog/projects/socket-activation.html" target="_blank" rel="noopener">简单</a>——并不同于从头创建一个监听socket。因此，很多广泛应用的软件（如<a href="http://trac.nginx.org/nginx/ticket/237" target="_blank" rel="noopener">ngix</a>）并不支持这种方式，软件容器化的趋势添加了另外需要激活的层则进一步加剧了这种限制条件的影响。但是可以通过将其交给容器的方式针对任意容器化的应用解决此问题。</p>
<h1 id="Socket激活和Docker"><a href="#Socket激活和Docker" class="headerlink" title="Socket激活和Docker"></a>Socket激活和Docker</h1><p>如果你Google “docker container systemd socket activation” 你会发现很少的相关的讨论，大部分的结论都是除非Docker给出了这方面的支持否则不可能，但Dcoker支持虽然是最优的解决方式但并不是全部。Sytemd的开发者已经知识在任意情况下都可以激活可能解决起来颇费周折，因此在<a href="http://article.gmane.org/gmane.comp.sysutils.systemd.devel/16993" target="_blank" rel="noopener">209</a>版本时引入了<a href="http://www.freedesktop.org/software/systemd/man/systemd-socket-proxyd.html" target="_blank" rel="noopener">systemd-socket-proxyd</a>——一个小的TCP和UNIX域socket代理。这个东西才是真正的理解了激活的含义，它可以坐在网络和我们的容器之间，透明地在二者之间转发包，因此我们可以通过少许的<a href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="noopener">units</a>（systemd的配置系统）为Docker容器创建一个socket激活的框架。</p>
<p><strong>警示</strong>：当前的Ubuntu发行版本systemd是208版本，还没有systemd-socket-proxyd，要想试验下述例子必须systemd 209版本或更高，Debian的Jessie pre-release版本可以，基于RedHat的最新的发行版如Fedora应该也可以。</p>
<h1 id="如何工作的"><a href="#如何工作的" class="headerlink" title="如何工作的"></a>如何工作的</h1><p>通常，我们用一个演示来简化说明问题：</p>
<p><img src="https://developer.atlassian.com/blog/2015/03/docker-systemd-socket-activation/systemd-docker.gif" alt="system activation animation"></p>
<p>我们看一下到底发生了什么事情：</p>
<ol>
<li>我们创建了一个socket监听相应的端口，它是由代理/容器依事件驱动合并进行服务的；</li>
<li>当第一个连接来的时候，systemd激活了代理服务用来处理这个socket；</li>
<li>还有一个由容器提供的被动式服务——代理依赖于此服务，代理启动之前首先要启动这个容器；</li>
<li>代理负责在网络和容器之前传送所有的流量。</li>
</ol>
<p>虽然需要一些技巧，但从概念上讲这是相当简单的，那么我们以systemd和一个ngix的容器来练习一下如何实现。</p>
<h1 id="使其运行"><a href="#使其运行" class="headerlink" title="使其运行"></a>使其运行</h1><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>首先我们要创建目标容器，这里我们利用<a href="https://registry.hub.docker.com/_/nginx/" target="_blank" rel="noopener">官方镜像</a>创建一个空的ngix容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create --name ngix8080 -p 8080:80 ngix</span><br></pre></td></tr></table></figure>
<p>这与你执行任何容器均类似，不过注意我们用的是<em>create</em>而不是<em>run</em>，因为我们并不想这个容器马上启动，我们还对此窗口进行了命名以便于后面启动它。</p>
<p>这里唯一一点技巧是你需要将此容器绑定到另外一个端口（这里我们用的是8080代替的80），这是因为这个端口（80）</p>
<p>现在我们有了一个容器，这样便可以创建激活管道，首先我们需要初始的监听socket也就是<a href="http://www.freedesktop.org/software/systemd/man/systemd.socket.html" target="_blank" rel="noopener">socket unit</a>，这个socket的行为是高度可配置的，但是我们的例子中非常简单。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Socket]</span></span><br><span class="line"><span class="attr">ListenStream</span>=<span class="number">80</span></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=socktes.target</span><br></pre></td></tr></table></figure>
<p><em>[Socket]</em>节表示一个简单的80端口的和TCP监听，<em>[Install]</em>节告诉systemd什么时候启动这个socket，在此例中它与系统配置的其他socket一起启动。我们将此unit写入名为<em>/etc/systedm/system/nginx-proxy.socket</em>的文件中，这只是启动后需要激活的链条中的一部分，我们还需要告诉systemd启动它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx-proxy.socket</span><br><span class="line">systemctl start nginx-proxy.socket</span><br></pre></td></tr></table></figure>
<h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p>当systemd接收到一个到此socket的连接时它化自动查找一个相同名称的<a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html" target="_blank" rel="noopener">服务</a>并启动它。我们需要创建服务文件<em>/etc/systemd/systedm/nginx-proxy.service</em>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Requires</span>=nginx-docker.service</span><br><span class="line"><span class="attr">After</span>=nginx-docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/lib/systemd/systemd-socket-proxyd <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p><em>[Unit]</em>节描述了此服务的依赖，此例中我们告诉systemd在代理启动之前必须先将实际的容器（下面我们将要配置此服务）启动。<em>[Section]</em>节为启动代理进程的响应，当前此节还可以配置<a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html" target="_blank" rel="noopener">大量的内容</a>，比如进程启动失败的处理，但是对于我们的应用一个简单的启动就OK了。注意我们将socket转发到了8080端口，这是我们的容器将要监听的端口；我们也并没有告诉systemd监听80端口，它只是用了systemd处理的socket。还要注意到上述配置文件中没有<em>[Install]</em>节，此服务并非是缺省启动，而是由socket激活它。</p>
<h2 id="启动Docker容器"><a href="#启动Docker容器" class="headerlink" title="启动Docker容器"></a>启动Docker容器</h2><p>正如前面提到了，代理利用<em>Requre/After</em>机制触发了容器的启动，此容器的启动文件在<em>/etc/systemd/system/nginx-docker.service</em>，它看起来是这样的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=nginx container</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker start -a nginx8080</span><br><span class="line"><span class="attr">ExecStartPost</span>=/bin/sleep <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/docker stop nginx8080</span><br></pre></td></tr></table></figure>
<p>与上述代理服务的基本概念相同，<em>ExecStart</em>行告诉systemd如何启动这个容器，systemd喜欢让进程不要在后台运行，所以我们添加了<em>-a</em>参数，这使得此容器在前台运行并且将nginx的运行日志转发到<a href="http://0pointer.de/blog/projects/journalctl.html" target="_blank" rel="noopener">journald</a>logger中，<em>ExecStop</em>告诉systemd当运行<em>systemctl stop ngix-docker</em>时如何停止容器。</p>
<p>这里我们还利用<em>ExecStartPost</em>行耍了一个小聪明，这是systemd在主进程启动后立马要运行的进程，此例中我们在继续往下走之前让其sleep了1秒钟。这是必要的，因为尽管docker启动容器非常快，但是容器中的进程的启动可能需要稍微长一点的时间完成初始化，systemd也非常快，所以有可能代理在nginx准备好接收之前就开始转发了，所以我们添加了一点延迟，给Dcoker/nginx一个空闲启动，这有点耍赖但是很有效（但是看<a href="#容器服务改进">下面</a>）</p>
<h1 id="一切就绪"><a href="#一切就绪" class="headerlink" title="一切就绪"></a>一切就绪</h1><p>现在你可以：当systemd启动的时候开启一个socket，当第一个连接到达时，级联的依赖关系会使nginx Docker通过代理对此连接进行响应。Easy。</p>
<h1 id="容器服务改进"><a href="#容器服务改进" class="headerlink" title="容器服务改进"></a>容器服务改进</h1><p>任何想要优化系统启动时间的人都恨死了在代码或配置文件中随意添加诸如<em>sleep</em>的语句，他们要么是因系统很快而不需要此延迟，要么是得到了很多难以定位的随机错误。上述<em>ExecStartPost</em>中的<em>sleep</em>语句也同样使我神经过敏，所以我也想把它删了。其实我们真正想做的是确认端口的监听已经启动了，但是通过了一种sleep的方式。我们可以通过一种循环检测端口是否已经正常启动的方式来实现，我用<a href="http://en.wikipedia.org/wiki/Netcat" target="_blank" rel="noopener">netcat</a>写了一个wrapper的脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">host=$1</span><br><span class="line">port=$2</span><br><span class="line">tries=600</span><br><span class="line"></span><br><span class="line">for i in `seq $tries`; do</span><br><span class="line">    if /bin/nc -z $host $port &gt; /dev/null ; then</span><br><span class="line">        # Ready</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    /bin/sleep 0.1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> FAIL</span><br><span class="line">exit -1</span><br></pre></td></tr></table></figure>
<p>这个脚本需要一个host和port的参数，检查一下是否有响应，每秒钟检查10次，如果1分钟之内还没有响应就返回失败。我们将此脚本安装到<em>/usr/local/bin/waitport</em>（设置其为可运行），现在我们的<em>nginx-docker.service</em>文件改为这样：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=nginx container</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker start -a nginx8080</span><br><span class="line"><span class="attr">ExecStartPost</span>=/usr/local/bin/waitport <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/docker stop nginx8080</span><br></pre></td></tr></table></figure>
<p>也就是说，waitport脚本可以根据你的系统应用灵活调整，如果你的容器启动速度很快的话通常都会立即返回。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2015/03/08/docker-systemd-socket-activation/" data-id="ck3ldyt8p00019eim82wccxu4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-haomama" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/15/haomama/" class="article-date">
  <time datetime="2014-11-15T14:47:54.000Z" itemprop="datePublished">2014-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/15/haomama/">好妈妈胜过好老师——现代儿童教育启示录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一句话的概括"><a href="#一句话的概括" class="headerlink" title="一句话的概括"></a>一句话的概括</h1><p>讲的是一种以孩子为核心的家庭教育方式，让人读后能够明白，在对待孩子的所有问题方面，是否充分考虑了孩子的需求和感受，而并非一味的从一个成年人的角度考虑问题。以孩子的兴趣为出发点引导孩子向好的方向发展，才是儿童教育的正道。这本书对每位父母而言都是必读的经典。</p>
<h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>老婆推荐我看的一本书《好妈妈胜过好老师——一个教育专家16年的教子手记》，作者尹建莉，作家出版社2009年1月出版。和一个同事一起出差，她推荐我看一本投资方面的书，我却看不下去，拿出这本《好妈妈胜过好老师》来看，回家后给老婆一说起此事，老婆也觉得有些好笑，但看完这本书后确实受益匪浅。</p>
<p>其实每个人都希望自己的孩子能够成才，甚至大部分都希望至少要比自己这一辈能够更加出息。因此，希望孩子能够懂礼貌、有教养、多才多艺、学习成绩要名列前矛，这应该是每一个作父母的所期盼的。但是随着生活条件的逐步提高，在子女教育上的物质投入也越来越高，但现代社会上存在的问题儿童却越来越多。</p>
<p>儿童的教育，父母是第一位的，父母可能会很有钱，给孩子上名牌的小学、中学，但是如果家庭的教育或者说父母的教育方式不当，最终还是难以取得较好的效果。</p>
<h1 id="家庭教育是否一切以孩子为核心"><a href="#家庭教育是否一切以孩子为核心" class="headerlink" title="家庭教育是否一切以孩子为核心"></a>家庭教育是否一切以孩子为核心</h1><p>书中讲的几个观点印象特别深，其中最核心的是，在教育孩子的过程中，你是不是以孩子为核心，能否充分考虑孩子的感受。书中举了很多这样的例子，比如她女儿的同学告诉女儿说家里有两柄剑，但这是个秘密，如果你告诉了别人，你的肚子会被刺穿，女儿信以为真，为此事非常烦恼，后来终于鼓足勇气将此事告诉了妈妈。这时候的妈妈并没有像一般人似的嘲笑孩子，而是耐心地给孩子讲道理，充分考虑到了孩子为了保守这个秘密自己承受了多大的痛苦，虽然这些痛苦在大人们看来挺可笑的，但对于孩子而言这却非常重要，如果你去嘲笑孩子以为非常重要的事情，对孩子形成的负面影响将会很大。再有作者比较后悔的一次，带着女儿和另外一个亲戚的小孩去爬山，两个小孩子在非要在地上爬着走，大人硬是把孩子提起来了，后来孩子抱怨说，大人们根本就没有了解孩子，因为他们觉得既然是爬山，为什么不是爬着走，孩子的童趣就在这里，而大人则要考虑孩子的衣服这些锁事，扼杀了孩子的乐趣。</p>
<p>有些孩子调皮，有些孩子表现出来的是听话，但调皮和听话仅仅是表面现象，核心的是是否真正地理解了孩子的所做所为，每一个孩子其实都是挺上进的，他们不喜欢当差生，也并不喜欢总被家长和老师骂，但是每一次父母以为孩子的错误是否从孩子的角度切实地考虑和分析了呢，或者是单纯地以大人的观点去作判断。</p>
<h1 id="每一个孩子都是天使"><a href="#每一个孩子都是天使" class="headerlink" title="每一个孩子都是天使"></a>每一个孩子都是天使</h1><p>每一个孩子都是天使，理应生活在童话的世界里，他们的乐趣其实很简单，但是很多大人却不能站在孩子的角度理解他们。作者夫妇会注意孩子的需求，然后每年圣诞节会有圣诞老人给孩子送礼物，孩子觉得很神奇，甚至在学校里还和老师争辩圣诞老人的有无问题。是啊，童年很是短暂，孩子是天使，理应生活在童话的世界里，等逐渐长大后，便又成了凡人。</p>
<h1 id="阅读的习惯对孩子的基础素质无比重要"><a href="#阅读的习惯对孩子的基础素质无比重要" class="headerlink" title="阅读的习惯对孩子的基础素质无比重要"></a>阅读的习惯对孩子的基础素质无比重要</h1><p>要尽早培养孩子阅读的习惯，如果孩子能够对阅读感兴趣，会带来很多额外的好处，一是他们可以大大的开拓视野和知识面，二是他们可以为后续的表达能力、写作能力打下很好的基础，三是可以不会沉沦于看电视和玩游戏。其实我自小没有养成很好的阅读习惯，致使现在读的书也偏少。记得一次上中学的时候，自己在家偷偷拿一本武侠小说看，被父亲看到了，狠狠地批评了我一通，后来再也不敢在家里看武侠小说了。高中的时候，仅记得看过一本评书类似的《薜丁山征西》，如果在我中小学时有条件的话，能够多看一些文学水平较高的小说，可能会对我的一生都会有较重要的影响。我无意责备自己的父母，但是在自己教育孩子的过程中却真要避免犯类似的错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/11/15/haomama/" data-id="ck3ldyt8x00089eimj597tnk2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Misc/">Misc</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-understanding-docker" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/31/understanding-docker/" class="article-date">
  <time datetime="2014-10-31T14:16:39.000Z" itemprop="datePublished">2014-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/31/understanding-docker/">理解Docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文出自<a href="https://docs.docker.com/introduction/understanding-docker/，" target="_blank" rel="noopener">https://docs.docker.com/introduction/understanding-docker/，</a> 本文由<a href="mailto:&#100;&#101;&#101;&#114;&#108;&#117;&#120;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#100;&#101;&#101;&#114;&#108;&#117;&#120;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a>翻译。</p>
<h1 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h1><p>Docker是一个用于开发、装载和运行程度的开放平台，可使你的程序迁移更加便捷。在Docker中可以将你的应用程序和基础设施层隔离，并且还可以将你的基础设施当作程序一样进行管理。Docker可以帮助你更加快速地打包你代码、更加快速地测试、更加快速地部署，并且可以减少写代码到部署运行代码的周期。</p>
<p>Docker通过将一个轻量级的容器虚拟化平台和一组标准工作流程、工具进行集成，来帮助你方便地管理和部署应用。</p>
<p>核心的是，Docker提供了一种在一个安全隔离的环境中运行几乎所有程序方式，这种隔离性和安全性允许你在同一主机上同时运行多个容器，而容器的这种轻量级特性，意味着你可以节省更多的硬件资源，因为你不必消耗运行hypervisor所需要的额外负载的。</p>
<p>围绕容器虚拟化Docker提供了一些工具和一个平台，可为你提供以下帮助：</p>
<ul>
<li>将应用程序（包括支撑的组件）放入docker容器中；</li>
<li>将这些容器打包并分发给你的团队，以便于后续的开发和测试；</li>
<li>将这些容器部署到生产环境中，即可以是本地的数据中心也可以在云端。</li>
</ul>
<h1 id="我可以用Docker做些什么？"><a href="#我可以用Docker做些什么？" class="headerlink" title="我可以用Docker做些什么？"></a>我可以用Docker做些什么？</h1><h2 id="快速分发你的应用"><a href="#快速分发你的应用" class="headerlink" title="快速分发你的应用"></a>快速分发你的应用</h2><p>Docker是开发过程中较为理想的助手，它允许你在包含了你的应用和服务的本地容器中进行开发，然后帮你完成集成和部署。</p>
<p>例如，你的开发人员可以在本地写代码然后通过Docker与其他同事共享，当他们完成了各自的开发任务后，可以将他们的代码推送到一个测试的环境中进行测试，完成测试后便可以将相应的Docker镜像部署到生产环境中。</p>
<h2 id="更方便地进行部署和调整规模"><a href="#更方便地进行部署和调整规模" class="headerlink" title="更方便地进行部署和调整规模"></a>更方便地进行部署和调整规模</h2><p>Docker这种基于容器的平台具有高度的便携性，它可以无缝地运行于开发者的本地主机、数据中心其他的物理机或虚拟机、或者云端。</p>
<p>Docker的便携性和其天然的轻量特性易于实现动态地负载管理，你可以利用Docker快速地增减应用和服务的部署规模，Docker的速度保证了这种规模的调整近乎实时。</p>
<h2 id="更高密度的部署应用和运行更多的应用"><a href="#更高密度的部署应用和运行更多的应用" class="headerlink" title="更高密度的部署应用和运行更多的应用"></a>更高密度的部署应用和运行更多的应用</h2><p>由于Docker轻量并且快速，因此相对于基于Hypervisor的虚拟机的部署方式，Docker提供了一种更可行和划算的替代方案，这对于高密度部署环境尤其有用，例如在构建私有云或平台即服务环境时，当然，当你想在有限的资源里部署更多的应用时，Docker对于小中型的部署也非常有用。</p>
<h1 id="Docker主要包括哪些组件？"><a href="#Docker主要包括哪些组件？" class="headerlink" title="Docker主要包括哪些组件？"></a>Docker主要包括哪些组件？</h1><p>Docker主要包括两个组件：</p>
<ul>
<li>Docker: 开源的容器虚拟化平台；</li>
<li><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> ：用于分享和管理Docker容器的软件即服务平台。</li>
</ul>
<p><strong>注</strong>: Docker在Apache 2.0开源协议下进行授权。</p>
<h1 id="Docker的架构？"><a href="#Docker的架构？" class="headerlink" title="Docker的架构？"></a>Docker的架构？</h1><p>Docker是一种Client/Server的架构，Docker客户端与Docker daemon进行交互，daemon负责构建、运行和发布Docker容器。客户端即可以和服务端运行在同一个系统中，也可以连接远程的daemon。Docker的客户端的daemon通过RESTful API进行sockets 通信。</p>
<p><img src="https://docs.docker.com/article-img/architecture.svg" alt="docker-architecture.svg"></p>
<h2 id="Docker守护进程"><a href="#Docker守护进程" class="headerlink" title="Docker守护进程"></a>Docker守护进程</h2><p>就像上图所示，Docker守护进程(daemon)在主机上运行，用户不能直接和守护进程打交道，但是可以通过docker客户端与其进行交互。</p>
<h2 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h2><p>Docker客户端——<code>docker</code>二进制文件的功能之一——是Docker的初始用户界面，它接收用户的命令并反馈，并且与Docker的守护进行交互。</p>
<h2 id="Docker内部机制"><a href="#Docker内部机制" class="headerlink" title="Docker内部机制"></a>Docker内部机制</h2><p>理解Docker的内部机制，你需要明白如下三个组件：</p>
<ul>
<li>Docker镜像</li>
<li>Docker注册中心</li>
<li>Docker容器</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker镜像是一个只读的模块。例如，一个镜像可以包含一个安装了apache WEB服务应用的Ubuntu操作系统。镜像用来创建Docker容器。Docker提供了构建新镜像或升级原有镜像的较为便利的方式，或者你也可以下载别人已经创建好的镜像。Docker镜像是Docker的<strong>构建</strong>组件。</p>
<h3 id="Docker注册中心"><a href="#Docker注册中心" class="headerlink" title="Docker注册中心"></a>Docker注册中心</h3><p>Docker注册中心用于上传和下载镜像，有公共注册中心和私有注册中心两种。公共注册中心为<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，它提供了大量的现成镜像，你可以构建自己的镜像上传到上面，也可以在上面下载别人构建的镜像。Docker注册中心是Docker的<strong>发布</strong>组件。</p>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>Docker容器与一个目录很类似，它包含了一个应用程序运行所需要的一切内容。每个容器都是基于一个Docker镜像制作的。Docker容器可被运行、开始、停止、迁移或者是删除。每个容器均是一个隔离的、安全的应用平台。Docker容器是Docker的<strong>运行</strong>组件。</p>
<h2 id="Docker怎样工作的"><a href="#Docker怎样工作的" class="headerlink" title="Docker怎样工作的"></a>Docker怎样工作的</h2><p>至此，我们已经知道了：</p>
<ol>
<li>你可以构建用于存储你的应用程序的镜像；</li>
<li>你可以从Docker镜像中创建容器用来运行你的应用；</li>
<li>你可以通过<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>或者你自己的注册中心来共享Docker镜像</li>
</ol>
<p>那我们看看Docker是怎么将这些元素组合在一起工作的。</p>
<h3 id="Docker镜像是如何工作的"><a href="#Docker镜像是如何工作的" class="headerlink" title="Docker镜像是如何工作的"></a>Docker镜像是如何工作的</h3><p>我们已经知道Docker镜像实质上是一些用于加载Docker容器的只读模板，每个镜像包括很多层。Docker利用<a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">union file systems</a>将这些层组合为一个镜像。Union file systems允许相互隔离的文件或目录透明的叠加在一起，而呈现为一个统一的文件系统。</p>
<p>Docker如此轻量化的原因也是由于这些层的存在。当你对一个Docker镜像进行修改时——例如将一个应用升级为一个新的版本——会构建一个新的层，因此，与虚拟机的替换整个镜像或完全构建的方式不同，Docker仅对相关的层进行添加或升级。所以你仅需要发布镜像的更新部分而不必发布整个镜像，这种方式使得镜像的发布更加快速和简单。</p>
<p>每个镜像始于一个基础镜像，例如：<code>ubuntu</code>便是一个基础的Ubuntu镜像，<code>fedora</code>是一个基础的Fedora镜像。你也可以将你自己制作的镜像作为基础镜像，例如你可以将一个Apache镜像作为一个Web应用的基础镜像。</p>
<blockquote>
<p>注意：Docker一般从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>上获取基础镜像。</p>
</blockquote>
<p>Docker镜像从这些基础镜像中按照一系列的步骤进行制作，我们称这些步骤为<strong>指令</strong>，每个指令在你的镜像中创建一个新的层，指令包括以下行为：</p>
<ul>
<li>运行一条命令；</li>
<li>添加一个文件或目录；</li>
<li>创建一个环境变量；</li>
<li>从此镜像中加载一个容器时需要运行的进程。</li>
</ul>
<p>这些指令存储在<code>Dockerfile</code>中，Docker在构建镜像过程中读取这个<code>Dockerfile</code>，运行里面的指令并返回最终的镜像。</p>
<h3 id="Docker注册中心如何工作的"><a href="#Docker注册中心如何工作的" class="headerlink" title="Docker注册中心如何工作的"></a>Docker注册中心如何工作的</h3><p>Docker注册中心是Docker镜像的存储中心，当你构建完一个镜像后便可以将其推送到<a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>或你自己的注册中心。</p>
<p>利用Docker客户端，你可以搜索已经发布的镜像，然后将其拉取到你的Docker主机上，以便于从这些镜像中构建容器。</p>
<p><a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>为镜像提供了公共的和私有的存储空间。公共的存储空间任何人均可以在上面搜索和下载，私有存储空间仅对你本人或你的团队开放搜索以及拉取下载，你可以通过<a href="https://hub.docker.com/plans" target="_blank" rel="noopener">这里</a>注册一个私有的存储空间。</p>
<h3 id="容器是如何工作的"><a href="#容器是如何工作的" class="headerlink" title="容器是如何工作的"></a>容器是如何工作的</h3><p>一个容器包括操作系统、用户添加的文件以及相关的元数据。我们知道，每个容器都是从镜像中构建出来的，这个镜像告诉Docker容器用到什么资源、当容器加载时启动哪个进程以及容器启动时的其他配置。Docker镜像是只读的，当Docker从一个镜像运行一个容器时，它会在镜像的上层添加一个用于运行应用的可读写的层（利用的就是上文提到的union file system）。</p>
<h3 id="运行一个容器时到底发生了什么"><a href="#运行一个容器时到底发生了什么" class="headerlink" title="运行一个容器时到底发生了什么"></a>运行一个容器时到底发生了什么</h3><p>Docker客户端通过直接运行<code>docker</code>或者通过API调用的方式，可以通知Docker的守护进程运行一个容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -i -t ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>我们来看一下这个命令，Docker客户端利用<code>docker</code>命令跟一个<code>run</code>的选项启动一个容器，一个最小配置的Docker客户端运行一个容器需要告诉Docker守护进程以下事项：</p>
<ul>
<li>此容器基于什么镜像来构建，此处是<code>ubuntu</code>——一个基础的Ubuntu镜像；</li>
<li>需要在容器中运行的命令，此处是<code>/bin/bash</code>——在容器中启动一个Bash Shell。</li>
</ul>
<p>那么我们看看运行上述命令时到底发生了什么？</p>
<p>按照顺序，Docker依次干了如下事情：</p>
<ul>
<li><strong>拉取<code>ubuntu</code>镜像</strong> : Docker首先检查一下<code>ubuntu</code>镜像在本地服务器上存不存在，如果不存在，则自动从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>中下载，如果已经存在则直接利用这个镜像来启动一个新的容器。</li>
<li><strong>创建一个新的容器</strong>: 如果Docker本地服务器中存在这个镜像，那么就据此来启动一个容器。</li>
<li><strong>分配一个文件每户并且将其挂载到一个可读写的层</strong>: 容器在此文件系统中被创建，并且将其作为一个可读写的层添加到镜像中。</li>
<li><strong>分配一个网络或桥接的接口</strong>: 创建一个网络的接口以便于Docker容器能够访问本机。</li>
<li><strong>设置一个IP地址</strong>: 为此容器从地址池中找到并绑定一个IP地址。</li>
<li><strong>执行指定的进程</strong>: 运行你的应用程序，然后；</li>
<li><strong>获取并提供应用程序的输出</strong>: 连接标准输入、标准输出和标准错误接口，这样你便可以观察到程序运行的一切。</li>
</ul>
<p>现在你已经运行了一个容器，这样你便可以管理你的容器、与应用程序进行交互，当运行结束是停止或者删除你的容器。</p>
<h2 id="底层技术问题"><a href="#底层技术问题" class="headerlink" title="底层技术问题"></a>底层技术问题</h2><p>Docker是用Go语言实现的，用到了一些Linux内核的特性实现上述功能。</p>
<h3 id="命名空间（namespaces）"><a href="#命名空间（namespaces）" class="headerlink" title="命名空间（namespaces）"></a>命名空间（namespaces）</h3><p>Docker在为容器提供一个隔离的工作空间时，用到了<code>命名空间</code>的技术，当你运行一个容器时，Docker会为此容器创建一组命名空间。</p>
<p>这样便可以提供一个隔离的层：每个容器运行在自己的命名空间中，而外部不能访问这个层。</p>
<p>Docker用到的一些命名空间有：</p>
<ul>
<li><strong><code>pid</code>命名空间</strong>: 用于隔离进程（PID：Process ID）；</li>
<li><strong><code>net</code>命名空间</strong>: 用于管理网络；</li>
<li><strong><code>ipc</code>命名空间</strong>: 用于访问IPC资源（IPC：InterProcess Communication）；</li>
<li><strong><code>mnt</code>命名空间</strong>: 用于管理挂载点（MNT：Mount）；</li>
<li><strong><code>uts</code>命名空间</strong>: 用于隔离内核和版本标识（UTS：Unix Timesharing System）。</li>
</ul>
<h3 id="控制组（Control-Groups）"><a href="#控制组（Control-Groups）" class="headerlink" title="控制组（Control Groups）"></a>控制组（Control Groups）</h3><p>Docker还用到了另外一项技术叫<code>cgroups</code>或者叫控制组（control groups）。实现程序运行环境的隔离的关键在于使这些程序只用到他们需要的资源，这就能够保证这些容器是主机服务环境小社会中的好市民。控制组允许Docker在不同的容器之间共享硬件资源，需要时添加一些限制和约束，例如限制一个容器最大访问内存量。</p>
<h3 id="统一文件系统（Union-file-systems）"><a href="#统一文件系统（Union-file-systems）" class="headerlink" title="统一文件系统（Union file systems）"></a>统一文件系统（Union file systems）</h3><p>统一文件系统或者说是UnionFS，是创建层的时候用到的文件系统，使文件系统非常轻量和快速。Docker使用统一文件系统为容器构建blocks，Docker可以使用几种不同的文件系统：AUFS、btrfs、vfs以及DeviceMapper。</p>
<h3 id="容器格式"><a href="#容器格式" class="headerlink" title="容器格式"></a>容器格式</h3><p>Docker容器将这些组件合并在一起，我们称之为容器格式，容器的缺省格式称为<code>libcontainer</code>。Docker还支持利用<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXC</a>技术的传统Linux容器格式，未来还将会支持其他的容器格式，例如：与BSD Jails或者Solaris Zones实现整合。</p>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><p>安装Docker，请参照<a href="https://docs.docker.com/installation/#installation" target="_blank" rel="noopener">installation section</a></p>
<p>Docker用户指南，请参照<a href="https://docs.docker.com/userguide/" target="_blank" rel="noopener">深入学习Docker</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/31/understanding-docker/" data-id="ck3ldyt8z000b9eim7yt8dgu3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-guochan-os" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/24/guochan-os/" class="article-date">
  <time datetime="2014-10-24T13:21:33.000Z" itemprop="datePublished">2014-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/24/guochan-os/">国产操作系统与数据库——忍不住的吐槽</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因工作原因，一些系统要上国产化的操作系统、数据库和中间件，和这些国产化系统软件<br>的技术人员打交道碰到了一些让我无语的事情。</p>
<h1 id="iptables-F"><a href="#iptables-F" class="headerlink" title="iptables -F "></a>iptables -F </h1><p>我中间想和别的机子传一些文件，一看系统中的ssh服务已经启动起来了，于是在另外一台<br>机器上用ssh登录我的机器，但是明明是能够ping通的 <code>ssh my_ip</code> 却出现了 <code>no
route to host MY_IP</code>错误，我一看就怀疑可能是系统的iptables做了什么手脚，但无奈<br>我不会设置iptables。于是叫麒麟操作系统相关的技术人员来，非说我IP地址设置有问题<br>，弄了一通他没有弄明白，可能是技术支持的时候也没有碰到过我这样的用户，非要尝试<br>一下这种东西，最后信我的话了，直接用 <code>iptables -F</code> 给我把防火墙的东西清掉了。</p>
<p>我瞬间无语，其实我虽然不懂iptables的配置，但这条命令我还是懂得，就是删除所有的<br>iptables规则，那你他么还给我系统装什么iptables啊，国产化系统的安全就是这样保障<br>的啊？再说了，这也没有解决我问题啊，再重启还是不能，只是暂时可以通了。</p>
<h1 id="chomd-R-777"><a href="#chomd-R-777" class="headerlink" title="chomd -R 777 *"></a>chomd -R 777 *</h1><p>还有中间件的厂商更是另人蛋疼，号称是通过了公安部XXX认证的中间件厂商，给我的东西<br>是个压缩包，直接解压之后就可以用的，但是呢其中bin目录有些可执行的文件没有设置可<br>执行权限，我猜人家是在 windows 下打的压缩包，要不然怎会出现这种低级问题，不过人<br>家解决的方式也倒是简单，直接到了中间件解压后的根目录，敲了一条另我嘴巴合不拢的<br>命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 *</span><br></pre></td></tr></table></figure>
<p>看来人家还是习惯在windows下所有用户对所有文件都可读写的传统，这样的做WEB服务的<br>中间件能保证安全？可是我用Linux用点强迫症，ls后看到满屏的绿色，我气就不打一处来<br>。</p>
<h1 id="root用户安装的数据库只能root用"><a href="#root用户安装的数据库只能root用" class="headerlink" title="root用户安装的数据库只能root用"></a>root用户安装的数据库只能root用</h1><p>数据库产品也是，技术人员演示的是用root用户登录X系统，然后安装，然后运行数据库的<br>管理台。我是用普通用户登录，sudo安装，然后用普通用户打开控制台，不行。用sudo在<br>命令行里打开控制台可以。但是用普通用户打开控制台就报一个权限的错误，技术人员来<br>后坚持说root用户安装的就只能root用户用，如果想用普通用户用的话就用普通用户安装<br>。后来来了一个比他更懂行一些的，说可以将安装目录所有文件的属主改成我的登录用户<br>。我无语。后来我找到了问题的根源了，每个用户打开控制台的时候都会往安装目录下的<br>一个.manager目录里写log，如果普通用户没有对这个目录的写权限则就会报错。数据库系<br>统安装的时候将安装目录的权限都设置成了组可写的，因此比较恰当的做法是将允许使用<br>数据库的用户的组添加一个这个数据库目录的组即可。</p>
<p>由此我算得出了两个结论：</p>
<ul>
<li>技术支持人员素质太差，基础的Linux安全以及相关的内容知识匮乏。软件设计得不符合</li>
<li>Linux的规范，普通用户的log文件按照惯例应该是写在$HOME/.XXX目录下的，为什么要<br>往安装目录下写呢，典型的单用户windows系统的习惯。</li>
</ul>
<p>我们任重道远啊。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/24/guochan-os/" data-id="ck3ldyt8u00049eimv0bn4f5e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sqlalchemy" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/23/sqlalchemy/" class="article-date">
  <time datetime="2014-10-23T13:43:47.000Z" itemprop="datePublished">2014-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/23/sqlalchemy/">sqlalchemy的简单用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据库中表结构是现成的情况下ORM"><a href="#数据库中表结构是现成的情况下ORM" class="headerlink" title="数据库中表结构是现成的情况下ORM"></a>数据库中表结构是现成的情况下ORM</h2><p>前几天想自己在网上抓些东西然后存放在数据库中以便于后续的数据分析，只是不想自己<br>用DB-API写SQL语句去操作数据，所以才想用ORM的方式，可是看了半天sqlalchemy的文档<br>，都是在讲如何进行建库、建关系等，可是问题是我们经常要操作的数据库，库表的建立<br>并不是通过ORM的方式建，更希望是通过原始的SQL语句去建，对一个现成的数据库进行ORM<br>方式访问有没有更方便的方法呢？这种情况下有没有一种更方便的方式去访问数据库？答<br>案当然是肯定的。</p>
<p>比如我用来存储用户信息的sqlite数据库 (test.db) 结构是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">integer</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>sqlalchemy 0.9.1 之后增加了一种automap_base的机制，可以使现成的数据库中的数据结<br>构反射到类上。用来访问上述数据库中的表只需要简单几句就可以完成映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.automap <span class="keyword">import</span> automap_base</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    engine_str = <span class="string">'sqlite:///:test.db'</span></span><br><span class="line">    engine = sqlalchemy.create_engine(engine_str)</span><br><span class="line"></span><br><span class="line">    session = Session(engine)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面这两句话就完成了ORM映射 Base.classes.XXXX即为映射的类</span></span><br><span class="line">    <span class="comment"># Base.metadata.tables['XXX']即为相应的表</span></span><br><span class="line">    Base = automap_base()</span><br><span class="line">    Base.prepare(engine, reflect = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询操作</span></span><br><span class="line">    result = session.query(Base.classes.users).all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入操作</span></span><br><span class="line">    item = Base.classes.users(name=<span class="string">'lxq'</span>, password=<span class="string">'1234'</span>)</span><br><span class="line">    session.add(item)</span><br><span class="line">    session.commit()</span><br><span class="line">    </span><br><span class="line">    session.close()</span><br></pre></td></tr></table></figure>
<p>简单定义了两个类之后，不用关心数据表的内部实现，sqlalchemy会实现自动的映射，随<br>后手册上的很多操作都可以正常使用了。</p>
<h2 id="数据的修改"><a href="#数据的修改" class="headerlink" title="数据的修改"></a>数据的修改</h2><p>ORM系统对数据库中访问到的每一行数据会映射为一个唯一的Table对象，因此，当需要对<br>数据修改的时候，找到这行数据然后直接改其元素然后commit即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ed_user = session.query(User).filter_by(name=<span class="string">'ed'</span>).first()</span><br><span class="line">ed_user.name = <span class="string">'love'</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>利用单纯的ORM方式进行大批量的插入数据，由于是调用多条INSERT语句，因此效率十分低<br>下，session.add_all函数实际上也是调用了多条INSERT语句，如果想批量插入数据，可以<br>进行如下处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">engine.execute(User.__table__.insert(), </span><br><span class="line">    [&#123;<span class="string">'name'</span>:<span class="string">'hello'</span>, <span class="string">'password'</span>:<span class="string">'1234'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>:<span class="string">'hello2'</span>, <span class="string">'password'</span>:<span class="string">'1234'</span>&#125;])</span><br></pre></td></tr></table></figure>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>Lazy connecting<br><del>~</del><del>~</del><del>~</del>~</p>
<p>create_engine 按照手册上的说法是lazy_connecting，当你在create_engine的时候并不<br>会真正的建立数据库连接，而当第一次进行数据库相关操作的时候才会真正建立连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/23/sqlalchemy/" data-id="ck3ldyt8y00099eim4bna50me" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据之巅" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/14/数据之巅/" class="article-date">
  <time datetime="2014-10-14T13:52:56.000Z" itemprop="datePublished">2014-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/14/数据之巅/">数据之巅——从美国人历史上如何重视数据讲起大数据的前生今世</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者的文笔非常好，从美国建国时讲起，讲这个年轻的国家如何从一开始就重视数据的应<br>用的。古时候，美国的开国元勋们为了更公平地分配各州在议会中的席位，一直以各州的<br>人口基数为基础，而如果人口更多则这个州也将会承担更多的对于联邦政府的责任，所以<br>没有哪个州会对这种数据人为造假，因为有一种制衡机制。也正是因为如此，人口的多少<br>与这个州的权利和义务干系重大，因此在美国形成了以重视人口普查数据为起点的重视一<br>切数据的观念。每一项决策要想在议会通过，都需要有大量的数据进行支撑权衡投入和产<br>出，以至于不得不对人的生命进行定价，而且有一套较为说服力的定价算法。数据基础建<br>设以及数据共享应用是大数据时代的基础中的基础，美国人很明白这个道理。</p>
<p>因此，大数据的概念和技术应用最先兴起在美国也就不足为怪了。而反观我国，目前大数<br>据的概念被炒的有点过热了，而且很多人都在跟风炒概念，特别是政府决策层。个人觉得<br>我国离大数据时代还有一定的距离，而且必将在大数据时代落后于美国，因为我们国家的<br>决策机制并非是数据驱动，而是领导意愿驱动的。一个决策的科学与否与领导人的个人能<br>力、战略眼光有强的关联性，这种情况下形不成一种重视数据的风气，因此也就不会出现<br>大数据时代共享共用数据的环境。里面讲的神州数码的一位专家说，我们的差距主要是在<br><strong>观念和文化</strong> ，我深表认同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/14/数据之巅/" data-id="ck3ldyt99000h9eimicwbqd0f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hexo-blog" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/11/hexo-blog/" class="article-date">
  <time datetime="2014-10-11T15:48:20.000Z" itemprop="datePublished">2014-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/11/hexo-blog/">hexo + github 发布静态博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>网上的教程很多，我这里只讲一下干货，也是自己的一个备忘。</p>
<h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h1><p>以archlinux下为例，其他的发行版请自行查找相关的软件包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S nodejs</span><br></pre></td></tr></table></figure>
<h1 id="系统中安装hexo"><a href="#系统中安装hexo" class="headerlink" title="系统中安装hexo"></a>系统中安装hexo</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="初始化blog目录"><a href="#初始化blog目录" class="headerlink" title="初始化blog目录"></a>初始化blog目录</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your/blog/dir</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h1 id="在目录中安装所依赖的库"><a href="#在目录中安装所依赖的库" class="headerlink" title="在目录中安装所依赖的库"></a>在目录中安装所依赖的库</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h1 id="修改-config-yml-文件"><a href="#修改-config-yml-文件" class="headerlink" title="修改 _config.yml 文件"></a>修改 <code>_config.yml</code> 文件</h1><p>主要是要修改下面几项</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span>          <span class="comment"># 你的博客名称</span></span><br><span class="line"><span class="attr">author:</span>         <span class="comment"># 你的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh_CN</span> <span class="comment"># 设置中文</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://deerlux.github.io</span>       <span class="comment"># 设置你要发布的地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog</span>                         <span class="comment"># 设置你要发布地址的子目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">pacman</span>                       <span class="comment"># 设置要使用的主题，个人推荐pacman，有很多国内适用的特性。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span>                             <span class="comment"># 如果你和我一样用github pages发布，请参照</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/deerlux/blog.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">gh-pages</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">Updated</span> <span class="string">by</span> <span class="string">hexo</span>          <span class="comment"># 这是git提交的消息，你可以改成你需要的。</span></span><br></pre></td></tr></table></figure>
<p>不过一直没有搞定如何设置github的repo为ssh格式的。</p>
<h1 id="安装并设置pacman主题"><a href="#安装并设置pacman主题" class="headerlink" title="安装并设置pacman主题"></a>安装并设置pacman主题</h1><p>首先到github上下载此主题。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your/blog/dir/themes</span><br><span class="line">git <span class="built_in">clone</span> git@github.com/A-limon/pacman</span><br></pre></td></tr></table></figure>
<p>然后进行配置，如果你有新浪微博、多说评论引擎等，可以直接进行配置，改写<br>themes/pacman/_config.yml文件即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/11/hexo-blog/" data-id="ck3ldyt8v00059eim0kkxqssz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-三体" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/11/三体/" class="article-date">
  <time datetime="2014-10-11T14:19:34.000Z" itemprop="datePublished">2014-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/11/三体/">三体——中国作家写的具有世界级水准的科幻小说</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="mailto:deerlux@163.com" target="_blank" rel="noopener">deerlux@163.com</a> 2014年 09月 30日</p>
<p>宇宙中到底有没有其他生命体或文明？</p>
<p>如果有的话，对地球来说到底意味着什么？<br>人类五千年的文明发展史如果拿到宇宙以亿年为单位的深化过程中应该如何看待？</p>
<p>如果地球的末日来临人类社会将呈现一种什么样的状态？</p>
<p>人类要为自己的无知傲慢和自私付出什么样的代价？是人类才有的特性吗？</p>
<p>作者铺开了一幅宏大的宇宙、太阳系的发展脉络画面，凭自己深厚的物理学识和哲学思考<br>向我们展示了几个世纪的地球文明发展与存亡。以下内容涉及剧透，不喜勿喷。</p>
<p>第一部讲的是受文革深度迫害的而对人类丑恶深恶痛绝的苦情女最终变成愤世女，发现了<br>太阳可以放大地球上发出的电磁波，从而使人类向外星系发出召唤的功率达到恒星的级别<br>，这个信号当然被外星文明收到了，而且是因受三体无规律运行而苦苦挣扎寻求一块更适<br>合生存地的文明。于是他们在同样对人类丑恶感到失望的愤世男及其三体组织的帮助下，<br>用两个光速运行的智子锁死了地球的基础研究，方法很简单，以光速干扰你所有的粒子对<br>撞机，并且将地球上所有的信息实时传送给了三体。战争还没有开始，地球对三体世界已<br>经是战场透明了，三体派出了一支舰队，四个世纪便可以到达地球。</p>
<p>第二部。三体文明思维透明，不会撒谎，而人类撒谎的本领估计放在宇宙的角度也可以名<br>列前矛，不利用这个优势简直是浪费，但人类除了思想外的一切对于三体世界已经透明了<br>，所以人类想用自己撒谎的本领启动了面壁计划掩饰自己真正的战略意图。四位面壁者被<br>赋予了很大的权利运用地球上的一切资源，两个都失败了，被地球上三体支持者们直接识<br>破。人类对于战胜三体看来基本无望了，那又何必担心四个世纪之后的末日呢，安心享受<br>现在吧，”给岁月以文明，而不是给文明以岁月”，于是人类的觉悟反而迎来了新的繁荣，<br>科技的发展榨取了基础理论积累的最后一点价值，使人类的舰队比三体舰队速度还要快，<br>人类完全有理由相信战胜三体指日可待，然而真正在末日之战来临时人类的傲慢以及与外<br>星文明的差距彻底毁灭了人类生存的希望，三千支恒星级战舰组成的傲慢的舰队瞬间被毁<br>，人类还有没有生存的希望？宇宙文明有两个公理，由这两个公理可以推导出宇宙社会学<br>，而宇宙社会学中最重要的黑暗森林法则是三体世界的命门，这个命门最终被面壁者发现<br>。并且已经试验证实，一颗恒星受光粒打击被灭，宇宙中存在无数的文明，如果你暴露了<br>自己，高级文明如何知道你是善意还是恶意，但为了生存还是先把你灭了吧，连三体也对<br>这种其他文明的打击很是惧怕，人类掌握了这个命门后以与三体同归于尽胁迫三体世界，<br>从而造成一种基于威慑的战略平衡，人类得以延续。</p>
<p>第三部的画面最为宏大。屌丝男临死得到一笔钱，他用这钱向联合国买了颗不起眼的星星<br>送给了自己暗恋的白富美，白富美参与了一项将一颗人类大脑送到三体航队云的计划，于<br>是屌丝男的大脑被很悲催的送走了。由于威慑的存在，人类与三体相安多年，使人类几乎<br>都忘记了三体的攻击性，所以将威慑的决策权给了一个充满爱的白富美。三体人早就判断<br>出这个充满爱的白富美不会启动同归于尽的威慑，于是迅速做出行动，毁灭你与你何干。<br>人类被三体人赶到了澳大利亚，人类在这块仅留在大陆上可以互相为粮食，直到数目减少<br>到这块大陆适合生存的地步。好在逃逸在外太空的一艘战舰上还有一群没那么有爱的人类<br>，向宇宙广播了三体的坐标，三体世界被灭，太阳系被灭只是时间问题，剩下的三体人也<br>没有精力和地球人耗下去了。人类自以为是的启动了掩体计划，以为在太阳系受到打击时<br>自己能够通过躲在远日行星的背面免于一死，孰不知如此简单的道理对于能够灭绝一个恒<br>星系的文明来讲能不明白吗。 屌丝男的大脑最终是被三体舰队捕获了，并且获得了新生，<br>逃走的这批三体人允许他给白富美一次对话，屌丝男通过三个童话故事告诉人类如何生存<br>下去，但人类却没有最终理解这三个童话故事的内涵，恒星级的灭绝就来临了。这次更狠<br>，将整个太阳系直接降维到一个二维平面，这是神一级的同归于尽的灭绝方式。白富美最<br>终靠空间曲率驱动的光速飞船逃了出去，也最终悟出了屌丝男三个童话的全部内涵，空间<br>曲率驱动的光速飞船一方面可以逃逸另一方面可以造成一片慢雾，以了降低光速的代价将<br>太阳系被神级文明看作是安全的。但一切为时已晚，以光速飞行的飞船大幅度穿越时空，<br>到达了屌丝男送她的星星的行星上，幸运的是这颗星星物理条件适合人居住，不幸的是人<br>文环境不适合，这是其他文明星际战争的路线。神级文明可以改变宇宙规律，可以再造宇<br>宙，当全宇宙降维，在这里仅有的人类何去何从。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://deerlux.github.io/blog/2014/10/11/三体/" data-id="ck3ldyt95000f9eimhtwc77a3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misc/">Misc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git-部署/">git 部署</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统运维/">系统运维</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟化/">虚拟化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Misc/" style="font-size: 10px;">Misc</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/git-部署/" style="font-size: 10px;">git 部署</a> <a href="/tags/系统运维/" style="font-size: 10px;">系统运维</a> <a href="/tags/虚拟化/" style="font-size: 10px;">虚拟化</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/04/21/gitolite/">利用gitolite实现自动部署的简易实现方式</a>
          </li>
        
          <li>
            <a href="/2015/03/17/archlinux-nginx-fastcgi/">Archlinux下安装nginx、Fastcgi</a>
          </li>
        
          <li>
            <a href="/2015/03/08/docker-systemd-socket-activation/">利用systemd按需激Docker容器</a>
          </li>
        
          <li>
            <a href="/2014/11/15/haomama/">好妈妈胜过好老师——现代儿童教育启示录</a>
          </li>
        
          <li>
            <a href="/2014/10/31/understanding-docker/">理解Docker</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>